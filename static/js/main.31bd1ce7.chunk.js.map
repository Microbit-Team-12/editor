{"version":3,"sources":["api/microbit-api-config.ts","api/microbit/helper/serial/parser.ts","api/microbit/helper/serial/reader.ts","api/microbit/interact.ts","api/microbit/connect.ts","components/APIDemo.tsx","index.tsx"],"names":["defaultConfig","connectOption","baudRate","dataBits","stopBits","parity","bufferSize","flowControl","requestOption","filters","usbVendorId","readOption","showLog","updateMs","cutLength","signalOption","replLineReady","executionDone","executionStart","mainPYException","execException","waitMsBeforeReboot","SerialParser","portReader","config","signal","this","safeReadUntil","outputStream","a","signals","safeReadUntilWithUpdate","str","write","kind","outputChunk","result","console","log","unsafeReadline","line1","lineNumberString","split","messageLine","startsWith","line2split","line","parseInt","type","message","end","SerialReader","serialBuffer","termination","read","value","bufferLimit","len","length","substring","token","index","indexOf","before","substr","readLoop","includes","splitBufferOnFirst","readLoopWithCut","tokens","update","bufferUpdated","matchedToken","forEach","updateTimer","setInterval","clearInterval","ConnectedMicrobitInteract","port","portWriter","portParser","writable","encoder","TextEncoderStream","readable","pipeTo","catch","err","getWriter","decoder","TextDecoderStream","getReader","portReaderHelper","code","replaceAll","readUntilNewREPLLine","codeInPythonString","codeToPythonString","Stream","getREPLLine","readUntilExecutionStart","readUntilExecuteDone","createConnection","open","reason","portInteract","interact","disconnection","Promise","resolve","reject","addEventListener","onDisconnect","event","removeEventListener","connectBySelection","navigator","serial","requestPort","connectByPariedDevice","getPorts","ports","connectByPlugIn","checkUSBInfo","info","undefined","f","usbProductId","waitForPort","target","getInfo","globalConnection","APIDemo","props","state","output","onStart","bind","onFlash","onCodeChange","onReboot","onExec","onInterrupt","onRun","connect","alert","className","onClick","onChange","readOnly","connection","c","then","e","setState","flash","execute","reboot","interrupt","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.31bd1ce7.chunk.js","sourcesContent":["//TODO: Rename\n\nexport interface ManagerOption {\n  /**\n   * Parameter used to connect serial port. See `SerialOptions`\n   */\n  connectOption: SerialOptions\n  /**\n   * Parameter used for filtering serial port. See `SerialPortRequestOptions`\n   */\n  requestOption: SerialPortRequestOptions\n  /**\n   * Parameter used for reader class\n   */\n  readOption: readOption\n  /**\n   * Parameter used for parser class\n   */\n  signalOption: SignalOption\n}\n\nexport interface readOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * Program output should be updated to the web every `updateMs` ms.\n   */\n  updateMs: number\n  /**\n   * Length of program output that should be kept.\n   * \n   * It is recommended to set this to 2 * maximum number of character in the textarea.\n   */\n  cutLength: number\n}\n\nexport interface SignalOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating waiting for user input code\n   */\n  replLineReady: string,\n  /**\n   * A string to be printed by `print` statement\n   * Before execution of user code\n   * Outputting is implemented by adding print statement before user code\n   */\n  executionStart: string,\n  /**\n   * A string to be printed by `print` statement \n   * After execution of given user code\n   * Outputting is implemented by adding print statement after user code\n   */\n  executionDone: string,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating an error occured\n   */\n  mainPYException: string,\n  execException: string,\n  /**\n   * Ms before microbit is rebooted to run `main.py`\n   * Allowing output buffer to be emptied before reboot\n   * \n   * Not used right now\n   */\n  waitMsBeforeReboot: number,\n}\n\nexport const defaultConfig: ManagerOption = {\n  connectOption: {\n    baudRate: 115200,\n    dataBits: 8,\n    stopBits: 1,\n    parity: 'none',\n    bufferSize: 4096,\n    flowControl: 'none'\n  },\n  requestOption: {\n    filters: [\n      { usbVendorId: 0x0d28 }\n    ]\n  },\n  readOption: {\n    showLog: true,\n    updateMs: 50,\n    cutLength: 1000\n  },\n  //maybe consider using regexp?\n  signalOption: {\n    showLog: true,\n    replLineReady: '>>> ',\n    executionDone: 'Execute Done: 0x3f3f3f3f',\n    executionStart: 'Execution Start: 0x3f3f3f3f',\n    mainPYException: 'Traceback (most recent call last):\\r\\n  File \"main.py\", line ',\n    execException:   'Traceback (most recent call last):\\r\\n  File \"<stdin>\", line 1, in <module>\\r\\n  File \"<string>\", line ',\n    waitMsBeforeReboot: 1\n  }\n};","import Stream from 'ts-stream';\nimport { MicrobitOutput } from '../../../microbit-api';\nimport { SignalOption } from '../../../microbit-api-config';\nimport { SerialReader } from './reader';\n\n/**\n * This class provides functions to read serial output of a specific procedure,\n * by using the reader helper class.\n * \n * Below is its mechaism. Based on following input of code\n * ```\n * 1|Get REPL Line|>>>\n * 2|Setup Code   |>>> file=open('main.py','w');s='print(executionStart)\\\\r\\\\nprint(1)\\\\r\\\\nprint(executionStart)';file.write(s);file.close();from microbit import *;sleep(0);reset();\n * 3|#Byte Written|8\n * 4|executionStart\n * 5|Code output  |1\n * 6|executionDone\n * 6|MicroPython v1.13 on 2021-02-19; micro:bit v2.0.0-beta.4 with nRF52833\n * 7|Type \"help()\" for more information.\n * 8|>>>\n * ```\n * \n * Error Sample (Flashing)\n * ```\n * Traceback (most recent call last):\n * File \"main.py\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n *\n * REPL Sample (Running)\n * ```\n * Traceback (most recent call last):\n * File \"<stdin>\", line 1, in <module>\n * File \"<string>\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n */\nexport class SerialParser {\n  portReader: SerialReader;\n  signal: SignalOption;\n\n  constructor(portReader: SerialReader, config: SignalOption) {\n    this.portReader = portReader;\n    this.signal = config;\n  }\n\n  /**\n   * Read until new repl line is ready\n   */\n  readUntilNewREPLLine(): Promise<void> {\n    return this.portReader.safeReadUntil(this.signal.replLineReady);\n  }\n\n  /**\n   * Read until indication of execution starting\n   */\n  readUntilExecutionStart(): Promise<void> {\n    return this.portReader.safeReadUntil(this.signal.executionStart + '\\r\\n');\n  }\n\n  /**\n   * Read until indication of execution finishing, \n   * recent output from serial will be sent to `outputStream`\n   */\n  async readUntilExecuteDone(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    const signals = [\n      this.signal.executionDone + '\\r\\n',\n      this.signal.mainPYException,\n      this.signal.execException\n    ];\n    const result = await this.portReader.safeReadUntilWithUpdate(\n      signals, \n      str => outputStream.write({\n        kind: 'NormalOutput',\n        outputChunk: str\n      })\n    );\n    console.log('Execution done');\n    \n    if (result !== this.signal.executionDone + '\\r\\n') {\n      //line1 indicates in which line of user code exception occured\n      //which is first line after mainPYException and execException\n      const line1 = await this.portReader.unsafeReadline();\n      const lineNumberString = line1.split(',', 2)[0];\n      //messageLine is in the form of 'ErrorType:ErrorMessage'\n      //exec is used in user code, the line following line1 may not be mssageLine\n      let messageLine = '  ';\n      while(messageLine.startsWith('  ')) messageLine = await this.portReader.unsafeReadline();\n      const line2split = messageLine.split(': ');\n      outputStream.write({\n        kind: 'ErrorMessage',\n        line: parseInt(lineNumberString)-1,\n        type: line2split[0],\n        message: line2split[1]\n      });\n    }\n    outputStream.end();\n  }\n}","import { readOption } from '../../../microbit-api-config';\n/**\n * This class provide convenient function for reading serial output.\n */\nexport class SerialReader {\n  private serialBuffer = ''\n  private portReader: ReadableStreamDefaultReader<string>\n  private config: readOption\n\n  constructor(portReader: ReadableStreamDefaultReader<string>, config: readOption) {\n    this.portReader = portReader;\n    this.config = config;\n  }\n\n  /**\n   * Read from serial until termination is true.\n   * \n   * Buffer will not be cut in this function.\n   */\n  private async readLoop(termination: (text: string) => boolean): Promise<void> {\n    while (!termination(this.serialBuffer)) {\n      const { value } = await this.portReader.read();\n      this.serialBuffer += value;\n    }\n  }\n\n  /**\n   * Read from serial until termination is true.\n   * \n   * Assuming only last *bufferLimit* characters decides termination,\n   * this readLoop cuts unnecessary part of the buffer\n   */\n  private async readLoopWithCut(termination: (text: string) => boolean, bufferLimit: number): Promise<void> {\n    while (!termination(this.serialBuffer)) {\n      const len = this.serialBuffer.length;\n      if (len >= bufferLimit) this.serialBuffer = this.serialBuffer.substring(len - bufferLimit);\n      const { value } = await this.portReader.read();\n      this.serialBuffer += value;\n    }\n  }\n\n  /**\n   * Split *buffer* on first occurence of token.\n   * \n   * PRE: buffer = before + token + after\n   * buffer = after\n   * return before\n   */\n  private splitBufferOnFirst(token: string): string {\n    const index = this.serialBuffer.indexOf(token);\n    const before = this.serialBuffer.substr(0, index);\n    this.serialBuffer = this.serialBuffer.substr(index + token.length);\n    return before;\n  }\n\n  /**\n   * This function read a line from serial, \n   * and returns that line. \n   * \n   * You should only use this function when you are certain about what's comming from serial.\n   */\n  async unsafeReadline(): Promise<string> {\n    const token = '\\r\\n';\n    await this.readLoop(str => str.includes(token));\n    return this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until token appears in serial output, and returns nothing.\n   * \n   * Reading is optimized by cutting unnecessary string,\n   * so length of buffer < length of token.\n   * \n   * This is useful when reading potential long output,\n   * and the content before token does not matter\n   */\n  async safeReadUntil(token: string): Promise<void> {\n    await this.readLoopWithCut(str => str.includes(token), token.length);\n    this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until one of the token from the token array appears in serial output,\n   * and returns the token that appear in serial.\n   * Its content is also periodcally updates to upstream and when the token appears. \n   * \n   * This is useful when reading potential long output,\n   * and recent content of some length matters. \n   * \n   * Consider the following cases, which make the implementation necessary.\n   * \n   * `while True: print(1)` \n   * A lot of output\n   * \n   * `a=input(\"You name:\")` \n   * New content only come out after every thing gets outputted\n   * (So user can input)\n   */\n  async safeReadUntilWithUpdate(tokens: Array<string>, update: (text: string) => void): Promise<string> {\n    let bufferUpdated = false;\n    let matchedToken = '';\n    const termination = (str: string) => {\n      bufferUpdated = true;\n      tokens.forEach(token => { if (str.includes(token)) matchedToken = token; });\n      return matchedToken !== '';\n    };\n    const updateTimer = setInterval(() => {\n      if (bufferUpdated) {\n        update(this.serialBuffer);\n        bufferUpdated = false;\n      }\n    }, this.config.updateMs);\n    await this.readLoopWithCut(termination, this.config.cutLength);\n    clearInterval(updateTimer);\n    update(this.splitBufferOnFirst(matchedToken));\n    return matchedToken;\n  }\n}\n","import Stream from 'ts-stream';\nimport { InteractWithConnectedMicrobit, MicrobitOutput } from '../microbit-api';\nimport { ManagerOption, SignalOption } from '../microbit-api-config';\nimport { SerialParser } from './helper/serial/parser';\nimport { SerialReader } from './helper/serial/reader';\nconst ctrlC = '\\x03';\n\nexport class ConnectedMicrobitInteract implements InteractWithConnectedMicrobit {\n  port: SerialPort;\n  portWriter!: WritableStreamDefaultWriter<string>;\n  portReader!: ReadableStreamDefaultReader<string>;\n  portParser!: SerialParser\n  signal: SignalOption;\n\n  constructor(port: SerialPort, config: ManagerOption) {\n    this.port = port;\n    this.signal = config.signalOption;\n    if (port.writable != null) {\n      const encoder = new TextEncoderStream();\n      encoder.readable.pipeTo(port.writable).catch((err) => { console.log('disconnected in pipe'); });\n      this.portWriter = encoder.writable.getWriter();\n    }\n    if (port.readable != null) {\n      const decoder = new TextDecoderStream();\n      port.readable.pipeTo(decoder.writable).catch((err) => { console.log('disconnected in pipe'); });\n      this.portReader = decoder.readable.getReader();\n\n      const portReaderHelper = new SerialReader(this.portReader, config.readOption);\n      this.portParser = new SerialParser(portReaderHelper, config.signalOption);\n    }\n  }\n\n  /**\n   * Convert a javascript string of python code to readable python code\n   */\n  private codeToPythonString(code: string): string {\n    /* \n    replaceAll From up to down\n      (1) user-used escape character. e.g. [\\][t]\n        This should still be [\\][t] in main.py\n        [\\][\\][t] in python string\n      (2) user-used [']\n        Because code is wrapped with ''\n        [\\]['] in python string\n      (3) new line created by user\n        Should be [\\r][\\n] in main.py\n        [\\][r][\\][n] in python string\n      Note:\n        replaceAll require ESNext.\n        But web serial already require a high version of chrome.\n    */\n    return (  'print(\\'' + this.signal.executionStart + '\\')'\n            + '\\r\\n' + code + '\\r\\n'\n            + 'print(\\'' + this.signal.executionDone + '\\')'\n    ) .replaceAll('\\\\', '\\\\\\\\')\n      .replaceAll('\\'', '\\\\\\'')\n      .replaceAll(/\\r?\\n/g, '\\\\r\\\\n');\n  }\n\n  /**\n   * Send ctrlC to stop code execution\n   * - If no code was running, new REPL line starts\n   * - If code was running, then keyboardInterrupt appears\n   *    Serial input unavaible for a few ms, then new REPL line starts.\n   * Returns when the REPL line is clean and usable\n   */\n  private async getREPLLine(): Promise<void> {\n    await this.portWriter.write(ctrlC);\n    await this.portParser.readUntilNewREPLLine();\n  }\n\n  async flash(code: string): Promise<Stream<MicrobitOutput>> {\n    /*Whole procedure with workaround note\n      - Get a clean REPL line, see getREPLLine()\n      - Send code to `main.py` to REPL\n          Observation: Microbit serial lose characters when multiple lines are inputted\n          Workaround: Put all code on one line\n          The logic might be:\n            Microbit does not have enough pin on the chip for serial hardware flow control.\n            So computer has no way of knowing microbit buffer is full.\n            And when the buffer is full, microbit serial start to lose character.\n\n            When all code is on one line, microbit does not do any hard work until \\r entered\n            Less likely for the buffer to be full and lose character\n      - Print(replDone)\n          On receving replDone, manager knows microbit finished writing to main.py\n          It is rebooting and all later output are program output\n      - Sleep for 0ms\n          In case there are characters in output buffer\n      - reboot\n          To run `main.py` in a fresh state\n    */\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'file=open(\\'main.py\\',\\'w\\');'\n      + 's=\\'' + codeInPythonString + '\\';'\n      + 'file.write(s);'\n      + 'file.close();'\n      + 'from microbit import *;'\n      + 'reset()\\r'\n    );\n    await this.portParser.readUntilExecutionStart();\n    this.portParser.readUntilExecuteDone(outputStream).catch(() => { outputStream.end(); });\n    return outputStream;\n  }\n\n  async execute(code: string): Promise<Stream<MicrobitOutput>> {\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      's=\\'' + codeInPythonString + '\\';'\n      + 'exec(s)\\r'\n    );\n    await this.portParser.readUntilExecutionStart();\n    this.portParser.readUntilExecuteDone(outputStream).catch(() => { outputStream.end(); });\n    return outputStream;\n  }\n\n  async reboot(): Promise<Stream<MicrobitOutput>> {\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'from microbit import *;'\n      + 'reset()\\r'\n    );\n    await this.portParser.readUntilExecutionStart();\n    const outputStream = new Stream<MicrobitOutput>();\n    this.portParser.readUntilExecuteDone(outputStream).catch(() => { outputStream.end(); });\n    return outputStream;\n  }\n\n  async interrupt(): Promise<void> {\n    await this.portWriter.write(ctrlC);\n    //Not reading for new REPL line here\n    //because portParser might already be reading.\n  }\n}","import { serial } from 'web-serial-polyfill';\nimport { FailedConnection, MicrobitConnection } from '../microbit-api';\nimport { defaultConfig, ManagerOption } from '../microbit-api-config';\nimport { ConnectedMicrobitInteract } from './interact';\n\n/**\n * Check if browser support WebSerial\n * Return true if WebSerial is supported\n * \n * If WebSerial is not supported but WebUSB is supported,\n * this function applys polyfill from Google.\n */\nexport function checkCompatability(): boolean {\n  if ('serial' in navigator) return true;\n  else {\n    if ('usb' in navigator) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (navigator as any).serial = serial;\n      return true;\n    } else return false;\n  }\n}\n\n/**\n * Given a unopenned serial port and configuration object,\n * Create a MicrobitConnection object\n */\nasync function createConnection(port: SerialPort, config: ManagerOption): Promise<MicrobitConnection | FailedConnection> {\n  try {\n    await port.open(config.connectOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Open Port',\n      reason: error.message\n    };\n  }\n  const portInteract = new ConnectedMicrobitInteract(port, config);\n  return {\n    kind: 'MicrobitConnection',\n    interact: portInteract,\n    disconnection: new Promise((resolve, reject) => {\n      const onDisconnect = (event: Event) => {\n        console.log('disconnected');\n        port.removeEventListener('disconnect', onDisconnect);\n        resolve();\n      };\n      port.addEventListener('disconnect', onDisconnect);\n    })\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By selecting a serial port in the native permission window.\n * \n * **This must be followed by a UserGesture within a time period**\n * \n * *In some rare cases, calling other function before this can result in a UserGesture Error*\n */\nexport async function connectBySelection(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  let port: SerialPort;\n  try {\n    port = await navigator.serial.requestPort(config.requestOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Obtain Port',\n      reason: error.message\n    };\n  }\n  return createConnection(port, config);\n}\n\n/**\n * Create a MicrobitConnection object\n * By connecting to a paried serial device\n * This does not require selecting device in the native window.\n */\nexport async function connectByPariedDevice(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  const ports = await navigator.serial.getPorts();\n  if (ports.length === 1) return createConnection(ports[0], config);\n  else return {\n    kind: 'ConnectionFailure',\n    type: 'Failed to Obtain Port',\n    reason: 'Multiple or No Serial Devices Available'\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By user plugging the device\n */\nexport async function connectByPlugIn(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  //Given serialPortInfo, check if it agrees with filters\n  function checkUSBInfo(info: SerialPortInfo, filters: SerialPortFilter[] | undefined): boolean {\n    if (filters === undefined) return true; //no constraint\n    else {\n      for (const f of filters) {\n        //for two property, no constraint or equal\n        if (f.usbProductId === undefined || f.usbProductId === info.usbProductId)\n          if (f.usbVendorId === undefined || f.usbVendorId === info.usbVendorId)\n            return true;\n      }\n      return false;\n    }\n  }\n  \n  return new Promise((resolve, reject) => {\n    /**\n     * A event listener function\n     * Resolves the promise when a device is plugged in\n     */\n    const waitForPort = async(event: Event) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const port: SerialPort = (event as any).port || event.target;\n      if (checkUSBInfo(port.getInfo(), config.requestOption.filters)) {\n        navigator.serial.removeEventListener('connect', waitForPort);\n        resolve(createConnection(port, config));\n      }\n    };\n    //add the listener\n    navigator.serial.addEventListener('connect', waitForPort);\n  });\n}","import React from 'react';\nimport { Stream } from 'ts-stream';\nimport { FailedConnection, MicrobitConnection, MicrobitOutput } from '../api/microbit-api';\nimport { checkCompatability, connectByPlugIn, connectBySelection, connectByPariedDevice} from '../api/microbit/connect';\nimport './APIDemo.css';\n\ntype APIDemoState = {\n  code:string,\n  output:string\n}\n\nconst exampleDoc = `from microbit import *\nwhile True:\n    print(1)\n    sleep(100)`;\n\nlet globalConnection: MicrobitConnection | null;\n\n\nclass APIDemo extends React.Component<unknown, APIDemoState> {\n  constructor(props: unknown) {\n    super(props);\n    this.state = {\n      code : exampleDoc,\n      output : ''\n    };\n    this.onStart = this.onStart.bind(this);\n    this.onFlash = this.onFlash.bind(this);\n    this.onCodeChange = this.onCodeChange.bind(this);\n    this.onReboot = this.onReboot.bind(this);\n    this.onExec = this.onExec.bind(this);\n    this.onInterrupt = this.onInterrupt.bind(this);\n    this.onRun = this.onRun.bind(this);\n    this.connect = this.connect.bind(this);\n    if(!checkCompatability()) alert('Browser not supported');\n  }\n\n  render(): JSX.Element {\n    return (\n      <div className=\"APIDemo\">\n        <header className=\"APIDemo-header\">\n          <button className=\"APIDemo-button\" onClick={this.onStart}>Start</button>\n          <button className=\"APIDemo-button\" onClick={this.onRun}>Run Code</button>\n          <button className=\"APIDemo-button\" onClick={this.onFlash}>Flash Code</button>\n          <button className=\"APIDemo-button\" onClick={this.onInterrupt}>Interrupt</button>\n          <button className=\"APIDemo-button\" onClick={this.onReboot}>Reboot</button>\n        </header>\n        <div className=\"APIDemo-textareas\">\n          <textarea value={this.state.code} onChange={this.onCodeChange} className=\"APIDemo-code\"></textarea>\n          <textarea value={this.state.output} readOnly className=\"APIDemo-output\"></textarea>\n        </div>\n      </div>\n    );\n  }\n\n  async connect(connection: Promise<MicrobitConnection | FailedConnection>):Promise<boolean>{\n    const c = await connection;\n    switch (c.kind) {\n      case 'ConnectionFailure':\n        alert(c.reason);\n        return false;\n      case 'MicrobitConnection':\n        globalConnection = c;\n        c.disconnection.then(async () => {\n          alert('Serial disconnected');\n          globalConnection = null;\n          await this.connect(connectByPlugIn());\n          alert('Serial reconnected');\n        });\n        return true;\n    }\n  }\n\n  onCodeChange(e: React.ChangeEvent<HTMLTextAreaElement>):void {\n    this.setState({\n      code: e.target.value\n    });\n  }\n\n  async onStart():Promise<void>{\n    if(!(await this.connect(connectByPariedDevice())))\n      this.connect(connectBySelection());\n    //this.connect(connectByPlugIn());\n  }\n\n  async onExec(outputStream: Stream<MicrobitOutput>):Promise<void>{\n    await outputStream.forEach( output => {\n      if (output.kind === 'NormalOutput') {\n        this.setState({\n          output: output.outputChunk\n        });\n      } else {\n        alert(output.type + output.message);\n      }\n    });\n  }\n\n  async onFlash():Promise<void>{\n    console.log('onFlash');\n    const code = this.state.code;\n    if (globalConnection !== null) {\n      this.onExec(await globalConnection.interact.flash(code));\n    }\n    else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onRun(): Promise<void> {\n    console.log('onFlash');\n    const code = this.state.code;\n    if (globalConnection !== null) {\n      this.onExec(await globalConnection.interact.execute(code));\n    }\n    else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onReboot():Promise<void>{\n    console.log('onReboot');\n    if (globalConnection !== null) {\n      this.onExec(await globalConnection.interact.reboot());\n    }\n    else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onInterrupt():Promise<void>{\n    if (globalConnection !== null) {\n      globalConnection.interact.interrupt();\n    }\n    else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n}\n\nexport default APIDemo;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport APIDemo from './components/APIDemo';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <APIDemo />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}