{"version":3,"sources":["api/microbit/interface/message.ts","api/microbit/interface/config.ts","api/microbit/impl/helper/parser.ts","api/microbit/impl/helper/reader.ts","api/microbit/impl/interact.ts","api/microbit/impl/connect.ts","resources/Duck.jpg","duck-code.tsx","components/TutorialViewer.tsx","components/APIDemo.tsx","index.tsx"],"names":["MicrobitState","defaultConfig","connectOption","baudRate","dataBits","stopBits","parity","bufferSize","flowControl","requestOption","filters","usbVendorId","readOption","showLog","updateMs","cutLength","signalOption","replLineReady","executionDone","executionStart","mainPYException","execException","waitMsBeforeReboot","SerialParser","portReader","config","startSignals","endSignals","this","safeReadUntil","outputStream","a","console","log","safeReadUntilWithUpdate","_","readErrors","result","str","write","kind","outputChunk","unsafeReadline","line1","lineNumberString","split","lineCount","messageLine","startsWith","line2split","line","parseInt","type","message","length","SerialReader","serialBuffer","termination","read","value","bufferLimit","len","substring","token","index","indexOf","before","substr","readLoop","includes","splitBufferOnFirst","readLoopWithCut","tokens","update","bufferUpdated","matchedTokenID","forEach","updateTimer","setInterval","clearInterval","ConnectedMicrobitInteract","port","portWriter","portParser","signal","state","portWriterStreamClosed","portReaderStreamClosed","Free","writable","encoder","TextEncoderStream","readable","pipeTo","catch","getWriter","decoder","TextDecoderStream","getReader","portReaderHelper","code","replace","readUntilNewReplLine","Busy","Error","codeInPythonString","codeToPythonString","Stream","getREPLLine","readUntilExecStart","readUntilExecDone","then","finally","end","prefix","endMarker","output","text","lines","completions","slice","trim","completion","push","cond","Promise","resolve","timer","waitUntil","cancel","abort","close","createConnection","open","reason","portInteract","interact","disconnection","addEventListener","onDisconnect","removeEventListener","connectBySelection","navigator","serial","requestPort","connectByPariedDevice","getPorts","ports","connectByPlugIn","checkUSBInfo","info","undefined","f","usbProductId","waitForPort","event","target","getInfo","theme","createMuiTheme","palette","primary","main","useStyles","makeStyles","button","flexGrow","border","borderRadius","color","height","padding","spacing","margin","textAlign","textTransform","xButton","backgroundColor","speech","prevSlideParams","jsonData","require","slideNames","Object","keys","tutorials","executeCorrespondingCommand","commandString","props","href","rel","lineNumber","lineText","strippedCodeLine","strippedTutorialLines","map","x","Fuse","includeMatches","isCaseSensitive","search","closestLine","highlights","writtenLine","perfectLine","bugCatcher","lengthWritten","lengthPerfect","highlightsWritten","iWritten","highlightsPerfect","iPerfect","locationPerfect","lookFor","locationWritten","pop","couple","long","iStart","lookAhead","i","highlightDiffLine","item","refIndex","convert","readableDiffMessage","readableErrorLineNumber","convertedLine","shift","Typography","display","parseSpeech","filter","Boolean","parsedCommand","parseTextCommand","StartSlides","initialSlide","classes","useState","slide","setSlide","width","src","duck","alt","size","className","Grid","container","justify","alignItems","buttons","xs","ThemeProvider","Button","variant","onClick","link","params","closeDuck","MakeButtons","PythonCode","isExpandable","highlightStart","highlightEnd","highlightedLines","fragments","isLineNumberValid","name","maxValue","isNaN","alert","lineNumbers","start","isExpanded","setState","hasFreeConnection","onRunFinished","onRun","currentOutput","onInsertIntoEditor","join","style","darcula","language","showLineNumbers","getDisplayedText","startIcon","PlayArrow","disabled","bind","endIcon","Visibility","VisibilityOff","onToggleExpand","DoubleArrow","React","Component","TutorialViewer","renderers","renderCode","markdown","APIDemo","tutorial","connection","editor","monaco","needDuck","errorString","errorLine","errorMonacoIDs","loader","init","t","removeErrorLineOfCode","fetch","r","fetchCompletions","getCompletions","languages","registerCompletionItemProvider","triggerCharacters","provideCompletionItems","model","position","__","getLineContent","j","column","startColumn","word","wordRange","endColumn","startLineNumber","endLineNumber","endsWith","suggestions","CompletionItemKind","Constant","label","insertText","range","suggestion","disconnect","callback","isEnabled","getState","exileDuck","getValue","renderDuck","onRunCell","defaultLanguage","defaultValue","onMount","handleEditorDidMount","options","minimap","enabled","fontSize","wrapperClassName","readOnly","renderHeaderButton","onStart","onFlash","onInterrupt","hasBusyConnection","onReboot","summonDuck","renderTutorial","renderEditor","renderOutput","c","connect","codeSnippet","selection","getSelection","getPosition","getModel","pushEditOperations","focus","ids","deltaDecorations","errorMonacoID","isWholeLine","flash","onExec","execute","reboot","interrupt","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uheAyBYA,E,wICkDCC,EAA+B,CAC1CC,cAAe,CACbC,SAAU,OACVC,SAAU,EACVC,SAAU,EACVC,OAAQ,OACRC,WAAY,KACZC,YAAa,QAEfC,cAAe,CACbC,QAAS,CACP,CAAEC,YAAa,QAGnBC,WAAY,CACVC,SAAS,EACTC,SAAU,GACVC,UAAW,KAGbC,aAAc,CACZH,SAAS,EACTI,cAAe,OACfC,cAAe,2BACfC,eAAgB,8BAChBC,gBAAiB,gEACjBC,cAAiB,0GACjBC,mBAAoB,I,iBCjEXC,EAAb,WAME,WAAYC,EAA0BC,GAAuB,yBAL7DD,gBAK4D,OAJ5DC,YAI4D,OAH5DC,kBAG4D,OAF5DC,gBAE4D,EAC1DC,KAAKJ,WAAaA,EAClBI,KAAKH,OAASA,EACdG,KAAKF,aAAe,CAClBD,EAAON,eAAiB,OACxBM,EAAOL,gBACPK,EAAOJ,eAETO,KAAKD,WAAa,CAChBF,EAAOP,cAAgB,OACvBO,EAAON,eAAiB,OACxBM,EAAOL,gBACPK,EAAOJ,eAlBb,wDA0BE,WACE,OAAOO,KAAKJ,WAAWK,cAAcD,KAAKH,OAAOR,iBA3BrD,uEAmCE,WAAyBa,GAAzB,SAAAC,EAAA,6DACMH,KAAKH,OAAOZ,SAASmB,QAAQC,IAAI,+BADvC,SAEuBL,KAAKJ,WAAWU,wBACnCN,KAAKF,cACL,SAAAS,GAAC,OAAI,QAJT,UAMiB,IANjB,8BAOIP,KAAKQ,WAAWN,GAPpB,mBAQW,GARX,iCASgB,GAThB,iDAnCF,6HAoDE,WAAwBA,GAAxB,eAAAC,EAAA,sDACMH,KAAKH,OAAOZ,SAASmB,QAAQC,IAAI,mBAGjCI,EAAS,EAJf,UAKoB,IAAXA,EALT,gCAMmBT,KAAKJ,WAAWU,wBAC7BN,KAAKD,YACL,SAAAW,GAAG,OAAIR,EAAaS,MAAM,CACxBC,KAAM,eACNC,YAAaH,OAVrB,OAamB,KAPfD,EANJ,SAasBP,EAAaS,MAAM,CACnCC,KAAM,iBAdZ,yBAiBiB,IAAXH,EAjBN,kCAiB0BT,KAAKQ,WAAWN,GAjB1C,QAkBMF,KAAKH,OAAOZ,SAASmB,QAAQC,IAAI,kBAlBvC,iDApDF,sHA4EE,WAAiBH,GAAjB,uBAAAC,EAAA,6DACMH,KAAKH,OAAOZ,SAASmB,QAAQC,IAAI,mBADvC,SAIsBL,KAAKJ,WAAWkB,iBAJtC,OAIQC,EAJR,OAKQC,EAAmBD,EAAME,MAAM,IAAK,GAAG,GAGzCC,EAAY,EACZC,EAAc,GATpB,UAUuB,IAAdD,IAAmBC,EAAYC,WAAW,MAVnD,kCAWwBpB,KAAKJ,WAAWkB,iBAXxC,QAWIK,EAXJ,OAYID,GAAa,EAZjB,uBAcQG,EAAaF,EAAYF,MAAM,MACrCf,EAAaS,MAAM,CACjBC,KAAM,eACNU,KAAMC,SAASP,GAAoB,EACnCQ,KAAMH,EAAW,GACjBI,QAAgC,IAAtBJ,EAAWK,OAAgB,GAAKL,EAAW,KAnBzD,iDA5EF,8DChCaM,EAAb,WAKE,WAAY/B,EAAiDC,GAAqB,yBAJ1E+B,aAAe,GAI0D,KAHzEhC,gBAGyE,OAFzEC,YAEyE,EAC/EG,KAAKJ,WAAaA,EAClBI,KAAKH,OAASA,EAPlB,mFAeE,WAAuBgC,GAAvB,yEACM7B,KAAKH,OAAOZ,SAASmB,QAAQC,IAAIL,KAAK4B,cAD5C,UAEUC,EAAY7B,KAAK4B,cAF3B,iCAG0B5B,KAAKJ,WAAWkC,OAH1C,gBAGWC,EAHX,EAGWA,MACP/B,KAAK4B,cAAgBG,EACjB/B,KAAKH,OAAOZ,SAASmB,QAAQC,IAAIL,KAAK4B,cAL9C,gEAfF,2HA8BE,WAA8BC,EAAwCG,GAAtE,2EACMhC,KAAKH,OAAOZ,SAASmB,QAAQC,IAAIL,KAAK4B,cAD5C,UAEUC,EAAY7B,KAAK4B,cAF3B,wBAGUK,EAAMjC,KAAK4B,aAAaF,SACnBM,IAAahC,KAAK4B,aAAe5B,KAAK4B,aAAaM,UAAUD,EAAMD,IAJlF,SAK0BhC,KAAKJ,WAAWkC,OAL1C,gBAKWC,EALX,EAKWA,MACP/B,KAAK4B,cAAgBG,EACjB/B,KAAKH,OAAOZ,SAASmB,QAAQC,IAAIL,KAAK4B,cAP9C,gEA9BF,yFAgDE,SAA2BO,GACzB,IAAMC,EAAQpC,KAAK4B,aAAaS,QAAQF,GAClCG,EAAStC,KAAK4B,aAAaW,OAAO,EAAGH,GAE3C,OADApC,KAAK4B,aAAe5B,KAAK4B,aAAaW,OAAOH,EAAQD,EAAMT,QACpDY,IApDX,mEA6DE,4BAAAnC,EAAA,6DACQgC,EAAQ,OADhB,SAEQnC,KAAKwC,UAAS,SAAA9B,GAAG,OAAIA,EAAI+B,SAASN,MAF1C,gCAGSnC,KAAK0C,mBAAmBP,IAHjC,gDA7DF,wHA4EE,WAAoBA,GAApB,SAAAhC,EAAA,sEACQH,KAAK2C,iBAAgB,SAAAjC,GAAG,OAAIA,EAAI+B,SAASN,KAAQA,EAAMT,QAD/D,OAEE1B,KAAK0C,mBAAmBP,GAF1B,gDA5EF,mIAkGE,WAA8BS,EAAuBC,GAArD,4BAAA1C,EAAA,6DACM2C,GAAgB,EAChBC,GAAkB,EAChBlB,EAAc,SAACnB,GAKnB,OAJAoC,GAAgB,EAChBF,EAAOI,SAAQ,SAACb,EAAOC,GACjB1B,EAAI+B,SAASN,KAAQY,EAAiBX,OAEjB,IAApBW,GAEHE,EAAcC,aAAY,WAC1BJ,IACFD,EAAO,EAAKjB,cACZkB,GAAgB,KAEjB9C,KAAKH,OAAOX,UAfjB,SAgBQc,KAAK2C,gBAAgBd,EAAa7B,KAAKH,OAAOV,WAhBtD,cAiBEgE,cAAcF,GACdJ,EAAO7C,KAAK0C,mBAAmBE,EAAOG,KAlBxC,kBAmBSA,GAnBT,gDAlGF,iE,SHoBY3E,O,eAAAA,I,gBAAAA,M,KInBZ,IAEagF,EAAb,WAWE,WAAYC,EAAkBxD,GAI5B,GAJoD,yBAVtDwD,UAUqD,OATrDC,gBASqD,OARrD1D,gBAQqD,OAPrD2D,gBAOqD,OANrDC,YAMqD,OALrDC,WAKqD,OAH5CC,uBAA+C,KAGH,KAF5CC,uBAA+C,KAGtD3D,KAAKqD,KAAOA,EACZrD,KAAKwD,OAAS3D,EAAOT,aACrBY,KAAKyD,MAAQrF,EAAcwF,KACN,MAAjBP,EAAKQ,SAAkB,CACzB,IAAMC,EAAU,IAAIC,kBACpB/D,KAAK0D,uBAAyBI,EAAQE,SAASC,OAAOZ,EAAKQ,UACxDK,OAAM,SAAC3D,GACNH,QAAQC,IAAI,2BAEhBL,KAAKsD,WAAaQ,EAAQD,SAASM,YAErC,GAAqB,MAAjBd,EAAKW,SAAkB,CACzB,IAAMI,EAAU,IAAIC,kBACpBrE,KAAK2D,uBAAyBN,EAAKW,SAASC,OAAOG,EAAQP,UACxDK,OAAM,SAAC3D,GACNH,QAAQC,IAAI,2BAEhBL,KAAKJ,WAAawE,EAAQJ,SAASM,YAEnC,IAAMC,EAAmB,IAAI5C,EAAa3B,KAAKJ,WAAYC,EAAOb,YAClEgB,KAAKuD,WAAa,IAAI5D,EAAa4E,EAAkB1E,EAAOT,eAhClE,4CAoCE,WACE,OAAOY,KAAKyD,QArChB,gCA2CE,SAA2Be,GAazB,OACE,UAAaxE,KAAKwD,OAAOjE,eAAzB,SACWiF,EADX,cAEexE,KAAKwD,OAAOlE,cAAgB,MAC3CmF,QAAQ,MAAO,QACdA,QAAQ,KAAM,OACdA,QAAQ,SAAU,YA9DzB,gEAwEE,8FACQzE,KAAKsD,WAAW3C,MA3EZ,QA0EZ,uBAEQX,KAAKuD,WAAWmB,uBAFxB,gDAxEF,gHAmFE,WAAYF,GAAZ,wBAAArE,EAAA,yDAiBMH,KAAKyD,QAAUrF,EAAcuG,KAjBnC,sBAiB+CC,MAAM,iCAjBrD,cAkBE5E,KAAKyD,MAAQrF,EAAcuG,KAErBE,EAAqB7E,KAAK8E,mBAAmBN,GAC7CtE,EAAe,IAAI6E,IArB3B,SAuBQ/E,KAAKgF,cAvBb,uBAwBQhF,KAAKsD,WAAW3C,MACpB,+BACWkE,EADX,iEAzBJ,wBAgCY7E,KAAKuD,WAAW0B,mBAAmB/E,GAhC/C,oCAiCIF,KAAKuD,WAAW2B,kBAAkBhF,GAC/BiF,MAAK,WACJ,EAAK1B,MAAQrF,EAAcwF,QAE5BwB,SAAQ,WACPlF,EAAamF,SAtCrB,wBAwCSrF,KAAKyD,MAAQrF,EAAcwF,KAxCpC,iCAyCS1D,GAzCT,iDAnFF,mHAmIE,WAAcsE,GAAd,wBAAArE,EAAA,yDACMH,KAAKyD,QAAUrF,EAAcuG,KADnC,sBAC+CC,MAAM,mCADrD,cAEE5E,KAAKyD,MAAQrF,EAAcuG,KAErBE,EAAqB7E,KAAK8E,mBAAmBN,GAC7CtE,EAAe,IAAI6E,IAL3B,SAOQ/E,KAAKgF,cAPb,uBAQQhF,KAAKsD,WAAW3C,MACpB,MAASkE,EAAT,eATJ,wBAYY7E,KAAKuD,WAAW0B,mBAAmB/E,GAZ/C,oCAaIF,KAAKuD,WAAW2B,kBAAkBhF,GAC/BiF,MAAK,WACJ,EAAK1B,MAAQrF,EAAcwF,QAE5BwB,SAAQ,WACPlF,EAAamF,SAlBrB,wBAoBSrF,KAAKyD,MAAQrF,EAAcwF,KApBpC,iCAqBS1D,GArBT,iDAnIF,0HA2JE,WAAqBoF,GAArB,mCAAAnF,EAAA,yDACMH,KAAKyD,QAAUrF,EAAcuG,KADnC,sBAC+CC,MAAM,wCADrD,cAEE5E,KAAKyD,MAAQrF,EAAcuG,KAErBY,EAAY,aACdC,EAAS,GALf,SAOQxF,KAAKgF,cAPb,uBAQQhF,KAAKsD,WAAW3C,MAAhB,UAAyB2E,EAAzB,OARR,wBASQtF,KAAKsD,WAAW3C,MAAM4E,GAT9B,yBAUQvF,KAAKuD,WAAW3D,WAAWU,wBAC/B,CAACiF,IACD,SAACE,GAAD,OAAUD,EAASC,KAZvB,yBAcQzF,KAAKgF,cAdb,WAgBEhF,KAAKyD,MAAQrF,EAAcwF,KAEN,KADf8B,EAAQF,EAAOvE,MAAM,QACjBS,OAlBZ,qBAmBU+D,EAAOC,EAAM,MAENJ,EArBjB,0CAqBgC,IArBhC,iCAuBgB,CAACG,IAvBjB,QAyBQE,EAAwB,GAzBhC,cA0BqBD,EAAME,MAAM,GAAI,IA1BrC,IA0BE,2BAAuC,CAA5BtE,EAA4B,sBACZA,EAAKuE,OAAO5E,MAAM,SADN,IACrC,4BAAW6E,EAAyC,SACnCpE,OAAS,GACtBiE,EAAYI,KAAKD,EAAWD,QAHK,gCA1BzC,uDAgCSF,GAhCT,iDA3JF,kHAkME,mCAAAxF,EAAA,yDACMH,KAAKyD,QAAUrF,EAAcuG,KADnC,sBAC+CC,MAAM,kCADrD,cAEE5E,KAAKyD,MAAQrF,EAAcuG,KAF7B,SAIQ3E,KAAKgF,cAJb,uBAKQhF,KAAKsD,WAAW3C,MACpB,oCANJ,cASQT,EAAe,IAAI6E,IAT3B,UAUY/E,KAAKuD,WAAW0B,mBAAmB/E,GAV/C,oCAWIF,KAAKuD,WAAW2B,kBAAkBhF,GAC/BiF,MAAK,WACJ,EAAK1B,MAAQrF,EAAcwF,QAE5BwB,SAAQ,WACPlF,EAAamF,SAhBrB,wBAkBSrF,KAAKyD,MAAQrF,EAAcwF,KAlBpC,iCAmBS1D,GAnBT,iDAlMF,6EAwNE,SAAkB8F,GAChB,OAAO,IAAIC,SAAQ,SAACC,EAAS3F,GAC3B,IAAM4F,EAAQjD,aAAY,WACpB8C,MACF7C,cAAcgD,GACdD,OAED,UA/NT,8DA0OE,iCAAA/F,EAAA,yDACMH,KAAKyD,QAAUrF,EAAcwF,KADnC,sBAC+CgB,MAAM,6CADrD,uBAEQ5E,KAAKsD,WAAW3C,MA9OZ,QA4OZ,uBAGQX,KAAKoG,WAAU,kBAAM,EAAK3C,QAAUrF,EAAcwF,QAH1D,gDA1OF,qHAqPE,sBAAAzD,EAAA,6DACEC,QAAQC,IAAI,4BADd,SAGQL,KAAKJ,WAAWyG,OAAO,oBAH/B,uBAIQrG,KAAK2D,uBAJb,cAKEvD,QAAQC,IAAI,kBALd,SAOQL,KAAKsD,WAAWgD,MAAM,oBAP9B,wBAQQtG,KAAK0D,uBARb,eASEtD,QAAQC,IAAI,kBATd,UAWQL,KAAKqD,KAAKkD,QAXlB,iDArPF,6D,SCmBeC,E,gFAAf,WAAgCnD,EAAkBxD,GAAlD,eAAAM,EAAA,+EAEUkD,EAAKoD,KAAK5G,EAAOvB,eAF3B,+EAIW,CACLsC,KAAM,oBACNY,KAAM,sBACNkF,OAAQ,KAAMjF,UAPpB,cAUQkF,EAAe,IAAIvD,EAA0BC,EAAMxD,GAV3D,kBAWS,CACLe,KAAM,qBACNgG,SAAUD,EACVE,cAAe,IAAIZ,SAAQ,SAACC,EAAS3F,GAMnC8C,EAAKyD,iBAAiB,cALD,SAAfC,EAAgBxG,GACpBH,QAAQC,IAAI,gBACZgD,EAAK2D,oBAAoB,aAAcD,GACvCb,YAlBR,0D,sBAiCO,SAAee,IAAtB,+B,4CAAO,0CAAA9G,EAAA,6DAAkCN,EAAlC,+BAA0DxB,EAA1D,kBAGU6I,UAAUC,OAAOC,YAAYvH,EAAOhB,eAH9C,OAGHwE,EAHG,gFAKI,CACLzC,KAAM,oBACNY,KAAM,wBACNkF,OAAQ,KAAMjF,UARb,iCAWE+E,EAAiBnD,EAAMxD,IAXzB,0D,sBAmBA,SAAewH,IAAtB,+B,4CAAO,0CAAAlH,EAAA,6DAAqCN,EAArC,+BAA6DxB,EAA7D,SACe6I,UAAUC,OAAOG,WADhC,UAEgB,KADfC,EADD,QAEK7F,OAFL,yCAE0B8E,EAAiBe,EAAM,GAAI1H,IAFrD,UAGoB,IAAjB0H,EAAM7F,OAHT,0CAG8B,CACjCd,KAAM,oBACNY,KAAM,wBACNkF,OAAQ,uCANL,iCAOU,CACb9F,KAAM,oBACNY,KAAM,wBACNkF,OAAQ,6CAVL,6C,sBAkBA,SAAec,IAAtB,+B,4CAAO,mBAEIC,EAFJ,qBAAAtH,EAAA,6DAEIsH,EAFJ,SAEiBC,EAAsB5I,GAC1C,QAAgB6I,IAAZ7I,EAAuB,OAAO,EAC5B,IAAD,gBACaA,GADb,IACH,2BAAyB,CAAC,IAAf8I,EAAc,QAEvB,SAAuBD,IAAnBC,EAAEC,cAA8BD,EAAEC,eAAiBH,EAAKG,qBACpCF,IAAlBC,EAAE7I,aAA6B6I,EAAE7I,cAAgB2I,EAAK3I,aACxD,OAAO,GALV,8BAOH,OAAO,GAXyBc,EAA/B,+BAAuDxB,EAAvD,kBAeE,IAAI4H,SAAQ,SAACC,EAAS3F,GAK3B,IAAMuH,EAAW,uCAAG,WAAMC,GAAN,eAAA5H,EAAA,sDAEZkD,EAAoB0E,EAAc1E,MAAQ0E,EAAMC,OAClDP,EAAapE,EAAK4E,UAAWpI,EAAOhB,cAAcC,WACpDoI,UAAUC,OAAOH,oBAAoB,UAAWc,GAChD5B,EAAQM,EAAiBnD,EAAMxD,KALf,2CAAH,sDASjBqH,UAAUC,OAAOL,iBAAiB,UAAWgB,OA7B1C,4C,gGCjGQ,MAA0B,iC,iBC0BnCI,EAAQC,YAAe,CAC3BC,QAAS,CACPC,QAAS,CACPC,KAAM,cAMNC,EAAYC,aAAY,SAACN,GAAD,MAAY,CACxCO,OAAQ,CACNC,SAAU,EACVC,OAAQ,EACRC,aAAc,EACdC,MAAO,QACPC,OAAQ,GACRC,QAASb,EAAMc,QAAQ,GACvBC,OAAQ,EACRC,UAAW,SACXC,cAAe,QAEjBC,QAAS,CACPP,MAAO,QACPQ,gBAAiB,UACjBP,OAAQ,GACRC,QAASb,EAAMc,QAAQ,GACvBE,UAAW,UAEbI,OAAQ,CACNZ,SAAU,EACVC,OAAQ,EACRC,aAAc,EACdC,MAAO,QACPE,QAASb,EAAMc,QAAQ,GACvBC,OAAQ,EACRC,UAAW,YAIXK,EAA4B,GAC1BC,EAAWC,EAAQ,KACnBC,EAAaC,OAAOC,KAAKJ,GAEzBK,EAAY,CAChB,WAAa,0DAIb,cAAgB,qSAelB,SAASC,EAA4BC,EAAuBC,GAC1D,MAAsB,kCAAlBD,EAEA,mBAAGE,KAAK,+BAA+BjC,OAAO,SAASkC,IAAI,aAA3D,mCAKuB,sBAAlBH,EA2BX,SAA6BC,GAC3B,GAAIA,EAAMG,YAAcH,EAAMI,SAAU,CACtC,IAAMC,EAAmBL,EAAMI,SAASvE,OAElCyE,EADWT,EAAUN,EAAgB,IACJtI,MAAM,MAAMsJ,KAAI,SAAAC,GAAC,OAAIA,EAAE3E,UAExDpF,EADO,IAAIgK,IAAKH,EAAuB,CAAEI,gBAAgB,EAAMC,iBAAiB,IAClEC,OAAOP,GAC3B,GAAI5J,EAAOiB,OAAS,EAAG,CACrB,IAAMmJ,EAAcpK,EAAO,GACrBqK,EAgBZ,SAA2BC,EAAqBC,GAC9C,IAAIC,GAAa,EACXC,EAAgBH,EAAYrJ,OAAcyJ,EAAgBH,EAAYtJ,OACtE0J,EAAoB,GAAQC,EAAW,EACvCC,EAAoB,GAAQC,EAAW,EAC7C,KAAOF,EAAWH,GAAiBK,EAAWJ,GAC5C,GAAIJ,EAAYM,KAAcL,EAAYO,GACxCF,IACAE,SAGA,GAAIF,EAAW,IAAMH,GAAiBK,EAAW,IAAMJ,EACrDC,EAAkBrF,KAAKsF,GAAWA,IAClCC,EAAkBvF,KAAKwF,KAAWA,EAIjB,IAAMJ,IACrBF,GAAa,OAGZ,CAEH,IAAMO,EAAsCC,EAAQV,EAAYnF,MAAMyF,EAAUA,EAAW,GAAIL,EAAaO,EAAU,IAEhHG,EAAsCD,EAAQT,EAAYpF,MAAM2F,EAAUA,EAAW,GAAIR,EAAaM,EAAU,IACtH,GAAIK,EAAiB,CACnB,KAAOL,EAAWK,GAAmBN,EAAkBrF,KAAKsF,GAAWA,IACvEA,GAAY,EACZE,GAAY,OACP,GAAIC,EAAiB,CAC1B,KAAOD,EAAWC,GAAmBF,EAAkBvF,KAAKwF,GAAWA,IACvEF,GAAY,EACZE,GAAY,OAEZH,EAAkBrF,KAAKsF,GAAWA,IAClCC,EAAkBvF,KAAKwF,GAAWA,IAM1C,KAAOF,EAAWH,GAChBE,EAAkBrF,KAAKsF,GACvBA,IAEF,KAAOE,EAAWJ,GAChBG,EAAkBvF,KAAKwF,GACvBA,IAIEN,GAAcF,EAAYM,EAAW,KAAOL,EAAYO,EAAW,KACrEH,EAAkBO,MAClBL,EAAkBK,OAGpB,SAASF,EAAQG,EAAgBC,EAAcC,EAAgBC,GAC7D,IAAK,IAAIC,EAAIF,EAAQE,IAAMF,EAASC,GAAaC,EAAI,EAAIH,EAAKnK,OAAQsK,IACpE,GAAIH,EAAKG,KAAOJ,EAAO,IAAMC,EAAKG,EAAI,KAAOJ,EAAO,GAAM,OAAOI,EAKrE,MAAO,CAACZ,EAAmBE,GAhFJW,CAAkB5B,EAAkBQ,EAAYqB,MACnE,OAAQ,qFAC6CrB,EAAYsB,SAAW,EADpE,iBACoF,uBACzFC,EAAQvB,EAAYqB,KAAMpB,EAAW,IAFhC,IAEqC,uBAFrC,4BAGmB,uBACxBsB,EAAQ/B,EAAkBS,EAAW,OAIxC,MAAQ,gFAGP,MAAQ,sHA/CJuB,CAAoBrC,GAGF,oCAAlBD,EAQX,SAAiCC,GAC/B,OAAIA,EAAMG,WACA,wDAEL,IAAMH,EAAMG,WAFP,0FAQA,iHAjBDmC,CAAwBtC,GAGxBD,EAgHX,SAASqC,EAAQ9K,EAAcwJ,GAG7B,IAFA,IAAMyB,EAAgB,GAEbP,EAAI,EAAGA,EAAI1K,EAAKI,OAAQsK,IAC3BA,IAAMlB,EAAW,IACnBA,EAAW0B,QACXD,EAAcxG,KAAK,+BACjB,cAAC0G,EAAA,EAAD,CAAY5D,MAAM,YAAY6D,QAAQ,SAAtC,SACGpL,EAAK0K,SAIVO,EAAcxG,KAAK,+BACjB,cAAC0G,EAAA,EAAD,CAAYC,QAAQ,SAApB,SACGpL,EAAK0K,QAKd,OAAOO,EAaT,SAASI,EAAYrD,EAAgBU,GAInC,OAFoBV,EAAOrI,MADhB,mBAC0B2L,OAAOC,SACXtC,KAAI,SAAAC,GAAC,OAbxC,SAA0BT,EAAuBC,GAC/C,IAAI8C,EAAoC/C,EAMxC,OALIA,EAAc3I,WAAW,OAG3B0L,EAAgBhD,EADGC,EAAcnE,MAAM,GAAI,GACaoE,IAEnD8C,EAMmCC,CAAiBvC,EAAGR,MAgFjD,SAASgD,GAAYhD,GAClC,OA7EF,SAAqBiD,EAAsBjD,GACzC,IAAMkD,EAAU3E,IAD2C,EAEjC4E,mBAASF,GAFwB,mBAEpDG,EAFoD,KAE7CC,EAF6C,KAK3D,OACE,eAAC,IAAD,CAAavE,OAAQ,IAAKwE,MAAO,IAAjC,UACE,8BACE,qBAAKC,IAAKC,EAAM1E,OAAQ,IAAKwE,MAAO,IAAKG,IAAI,mBAG/C,cAAC,IAAD,CAAYC,KAAM,KAElB,eAAC,IAAD,WACE,cAAC,IAAD,CAAWA,KAAM,KACjB,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAACjB,EAAA,EAAD,CAAYkB,UAAWT,EAAQ5D,OAA/B,SACGqD,EAAYnD,EAAS4D,GAAO9D,OAAQU,KAEvC,cAAC4D,EAAA,EAAD,CAAMC,WAAS,EAACC,QAAQ,SAASC,WAAW,aAAa/E,QAAS,EAAlE,SACGQ,EAAS4D,GAAOY,QAAQzD,KAAI,SAAU9B,GACrC,OACE,8BACE,cAACmF,EAAA,EAAD,CAAM1B,MAAI,EAAC+B,IAAE,EAAb,SACE,cAACC,EAAA,EAAD,CAAehG,MAAOA,EAAtB,SACE,cAACiG,EAAA,EAAD,CACER,UAAWT,EAAQzE,OACnB2F,QAAQ,YACRvF,MAAM,UACNwF,QAAS,WACH5F,EAAO6F,MAET/E,EAAkBd,EAAO8F,OACzBlB,EAAS5E,EAAO6F,OAEhBtE,EAAMwE,aAVZ,SAcG/F,EAAOhD,YAjBNgD,EAAOhD,gBA2B3B,cAAC,IAAD,CAAciI,KAAM,SAEtB,cAAC,IAAD,CAAaA,KAAM,IAAnB,SACE,cAAC,IAAD,CAAaA,KAAM,IAAnB,SACE,cAAC,IAAD,CAAcA,KAAM,IAApB,SACE,cAACS,EAAA,EAAD,CACER,UAAWT,EAAQ9D,QACnBgF,QAAQ,YACRV,KAAK,QACLW,QAAS,WACPrE,EAAMwE,aALV,SASG,eAaNC,CAAY/E,EAAW,GAAIM,G,8GCnT9B0E,G,kDAmDJ,WAAY1E,GAAyB,IAAD,EAQlC,GARkC,qBAClC,cAAMA,IA9CC2E,kBA6C2B,IAtC3BC,oBAsC2B,IA/B3BC,kBA+B2B,IA1B3BnJ,WA0B2B,IApB3BoJ,sBAoB2B,EAGlC,EAAKH,cAAe,EACpB,EAAKjJ,MAAQ,EAAKsE,MAAMxF,KAAKvD,MAAM,MACnC,EAAK2N,eAAiB,EACtB,EAAKC,aAAe,EAAKnJ,MAAMhE,OAE3B,EAAKgE,MAAMhE,OAAS,EAAG,CAEzB,IAAMqN,EAAY,EAAKrJ,MAAM,GAAGzE,MAAM,YACtC,GAAyB,IAArB8N,EAAUrN,OAAc,CAAC,IAKlBsN,EAAT,SAA2B7E,EAAoB8E,EAAcC,GAC3D,OAAIC,MAAMhF,IACRiF,MAAM,mBAAD,OAAoBH,EAApB,aAA6B9E,KAC3B,GAELA,EAAa,GACfiF,MAAM,GAAD,OAAIH,EAAJ,gCAAgC9E,KAC9B,KAELA,EAAa+E,KACfE,MAAM,GAAD,OAAIH,EAAJ,oDAAoDC,KAClD,IAfLG,EAAcN,EAAU,GAAG9N,MAAM,KACjCqO,EAAQ/N,SAAS8N,EAAY,IAC7BhK,EAAM9D,SAAS8N,EAAY,IAmB7BL,EAAkBM,EAAO,gBAAiB,EAAK5J,MAAMhE,SACpDsN,EAAkB3J,EAAK,cAAe,EAAKK,MAAMhE,UAChD4N,GAASjK,GACX,EAAKuJ,eAAiBU,EAAQ,EAC9B,EAAKT,aAAexJ,EAAM,EAAI,EAC9B,EAAKsJ,cAAe,GAEpBS,MAAM,6EAAD,OAA8EE,EAA9E,cAAyFjK,MAxCpE,OA8ClC,EAAKyJ,iBAAmB,EAAKpJ,MAAME,MAAM,EAAKgJ,eAAgB,EAAKC,cAEnE,EAAKpL,MAAQ,CACX8L,YAAa,EAAKZ,aAClBnJ,OAAQ,IAlDwB,E,kDA0DpC,WACExF,KAAKwP,SAAS,CAACD,YAAavP,KAAKyD,MAAM8L,e,0DAWzC,qCAAApP,EAAA,yDACEH,KAAKwP,SAAS,CACZhK,OAAQ,KAELxF,KAAKgK,MAAMyF,oBAJlB,uBAKIL,MAAM,+BACNpP,KAAKgK,MAAM0F,gBANf,0CAU6B1P,KAAKgK,MAAM2F,MAAM3P,KAAKgK,MAAMxF,MAVzD,cAUQtE,EAVR,OAWM0P,EAAgB,GAXtB,UAYQ1P,EAAa8C,SAAQ,SAACwC,GAC1B,OAAQA,EAAO5E,MACb,IAAK,eACHgP,EAAgBpK,EAAO3E,YACvB,MACF,IAAK,eACH,GAAoB,sBAAhB2E,EAAOhE,KAA8B,MACzCoO,EAAa,UAAMA,EAAN,yBAAoCpK,EAAOlE,KAA3C,cACrBkE,EAAOhE,KADc,aACLgE,EAAO/D,SAEnB,EAAK+N,SAAS,CACZhK,OAAQoK,OAvBd,QA0BE5P,KAAKgK,MAAM0F,gBA1Bb,iD,sFAkCA,WACE1P,KAAKgK,MAAM6F,mBAAmB7P,KAAK8O,iBAAiBgB,KAAK,S,8BAW3D,WACE,IAAIpK,EAeJ,OAbI1F,KAAKyD,MAAM8L,WACb7J,EAAQ1F,KAAK0F,OAEbA,EAAQ1F,KAAK8O,iBAET9O,KAAK4O,eAAiB,IACxBlJ,EAAK,CAAI,SAAJ,oBAAgBA,KAEnB1F,KAAK6O,aAAe7O,KAAK0F,MAAMhE,SACjCgE,EAAK,uBAAOA,GAAP,CAAc,YAIhBA,EAAMoK,KAAK,Q,oBAcpB,WACE,OAAO,gCACL,cAAC,KAAD,CACEC,MAAOC,KACPC,SAAS,KACTC,gBAAiBlQ,KAAKyD,MAAM8L,WAH9B,SAKGvP,KAAKmQ,qBAGR,sBAAKxC,UAAU,0BAAf,UACE,cAACQ,EAAA,EAAD,CACER,UAAU,wBACVS,QAAQ,YACRvF,MAAM,UACNuH,UAAW,cAACC,GAAA,EAAD,IACXC,UAAWtQ,KAAKgK,MAAMyF,oBACtBpB,QAASrO,KAAK2P,MAAMY,KAAKvQ,MAN3B,yBAYEA,KAAK2O,cACL,cAACR,EAAA,EAAD,CACER,UAAU,wBACVS,QAAQ,YACRoC,QAASxQ,KAAKyD,MAAM8L,WAAa,cAACkB,GAAA,EAAD,IAAgB,cAACC,GAAA,EAAD,IACjDrC,QAASrO,KAAK2Q,eAAeJ,KAAKvQ,MAJpC,wBAUF,cAACmO,EAAA,EAAD,CACER,UAAU,wBACVS,QAAQ,YACRvF,MAAM,YACN2H,QAAS,cAACI,GAAA,EAAD,IACTvC,QAASrO,KAAK6P,mBAAmBU,KAAKvQ,MALxC,gCAWDA,KAAKyD,MAAM+B,OAAO9D,OAAS,GAC5B,qBAAKiM,UAAU,kBAAf,SACG3N,KAAKyD,MAAM+B,gB,GApPKqL,IAAMC,WAwTVC,G,4MAoBnBC,UAAY,CAACxM,KAAM,EAAKyM,WAAWV,KAAhB,iB,gDAnBnB,SAAW/L,GACT,MAAsB,OAAlBA,EAAKyL,SACA,cAAC,GAAD,CACLzL,KAAMA,EAAKzC,MACX4N,MAAO3P,KAAKgK,MAAM2F,MAClBD,cAAe1P,KAAKgK,MAAM0F,cAC1BG,mBAAoB7P,KAAKgK,MAAM6F,mBAC/BJ,kBAAmBzP,KAAKgK,MAAMyF,oBAGzB,cAAC,KAAD,CACLM,MAAOC,KACPC,SAAUzL,EAAKyL,SAFV,SAIJzL,EAAKzC,U,oBAOZ,WACE,OAAO,cAAC,KAAD,CAAe4L,UAAU,oBAAoBqD,UAAWhR,KAAKgR,UAA7D,SACJhR,KAAKgK,MAAMkH,e,GAxB0BL,IAAMC,WCwLnCK,G,kDAzdb,WAAYnH,GAAiB,IAAD,8BAC1B,cAAMA,IACDvG,MAAQ,CACX2N,SAAU,yBACV5L,OAAQ,GACR6L,WAAY,KACZC,OAAQ,KACRC,OAAQ,KACRC,UAAU,EACVC,YAAa,GACbC,UAAW,EACXC,eAAgB,MJ/ChB,WAAYzK,WAEV,QAASA,YAEVA,UAAkBC,OAASA,SACrB,II4CkBiI,MAAM,yBAEjCwC,IAAOC,OAAO1M,MAAK,SAAA2M,GACjB1R,QAAQC,IAAIyR,MAEd,EAAKC,sBAAwB,EAAKA,sBAAsBxB,KAA3B,gBAlBH,E,qDAwB5B,WAA2B,IAAD,OACxByB,MAAM,0BACH7M,MAAK,SAAC8M,GAAD,OAAOA,EAAExM,UACdN,MAAK,SAACM,GAAD,OACJ,EAAK+J,SAAS,CACZ4B,SAAU3L,S,kCASlB,SAAqB6L,EAA6CC,GAAuB,IAAD,OACtFvR,KAAKwP,SAAS,CACZ8B,OAAQA,EACRC,OAAQA,IAGV,IAAMW,EAAgB,uCAAG,WAAO5M,GAAP,SAAAnF,EAAA,0DACnB,EAAKsP,oBADc,uBAErBrP,QAAQC,IAAR,eAAoBiF,IAFC,kBAGd,EAAK7B,MAAM4N,WAAYzK,SAASuL,eAAe7M,IAHjC,gCAIT,IAJS,2CAAH,sDAOtBiM,EAAOa,UAAUC,+BACf,SACA,CACEC,kBAAmB,CAAC,IAAK,IAAK,IAAK,KAC7BC,uBAFR,SAE+BC,EAAOC,EAAUlS,EAAGmS,GAAK,OAAD,sHAGnD,IAFMpR,EAAOkR,EAAMG,eAAeF,EAAStI,YACvCyI,EAAIH,EAASI,OAAS,EACnBD,GAAK,GAAiB,MAAZtR,EAAKsR,IAAYA,GAAK,EAHY,OAI7CE,EAAcF,EAAI,EAClBG,EAAOzR,EAAKsE,MAAMkN,EAAaL,EAASI,OAAS,GALJ,SAOzBX,EAAiBa,GAPQ,UAWxB,KAJrBpN,EAP6C,QAWnCjE,OAXmC,oBAY3CoE,EAAaH,EAAY,GACzBqN,EAAY,CAChBF,YAAaA,EAAc,EAC3BG,UAAWR,EAASI,OACpBK,gBAAiBT,EAAStI,WAC1BgJ,cAAeV,EAAStI,YAIrBrE,EAAWsN,SAAS,KArBwB,0CAsBxC,CACLC,YAAa,CAAC,CACZzS,KAAM2Q,EAAOa,UAAUkB,mBAAmBC,SAC1CC,MAAO1N,EACP2N,WAAY3N,EACZ4N,MAAOV,MA3BoC,iCAiC1C,CACLK,YAAa,CAAC,CACZzS,KAAM2Q,EAAOa,UAAUkB,mBAAmBC,SAC1CC,MAAO1N,EACP4N,MAAOV,EAEPS,WAAY3N,EAAWF,MAAM,GAAI,OAvCY,iCA+C5C,CACLyN,YAAa1N,EAAY4E,KAAI,SAACoJ,GAC5B,MAAO,CACL/S,KAAM2Q,EAAOa,UAAUkB,mBAAmBC,SAC1CC,MAAOG,EACPF,WAAYE,QApDiC,mD,kCA2E3D,WAA8B,IAAD,EAC3B,UAAA3T,KAAKyD,MAAM4N,kBAAX,SAAuBzK,SAASgN,e,gCAiBlC,SAAmBnO,EAAcoO,EAAsBC,GAAwC,IAAD,OAU5F,OACE,cAAC3F,EAAA,EAAD,CACER,UAAU,iBACVS,QAAQ,YACRV,KAAK,QACL4C,UAAWwD,IACXzF,QAfwB,WACtByF,IACFD,KAEAzE,MAAM,mBAAD,OAAoB3J,EAApB,2BACL,EAAK+J,SAAS,MAKhB,SAOG/J,M,+BASP,WAA8B,IAAD,EAC3B,OAAO,UAAAzF,KAAKyD,MAAM4N,kBAAX,eAAuBzK,SAASmN,cAAe3V,EAAcwF,O,+BAOtE,WAA8B,IAAD,EAC3B,OAAO,UAAA5D,KAAKyD,MAAM4N,kBAAX,eAAuBzK,SAASmN,cAAe3V,EAAcuG,O,wBAGtE,WAWE,MAT+B,KAA3B3E,KAAKyD,MAAMgO,YACE,cAAC,GAAD,CACbjD,UAAWxO,KAAKgU,UAAUzD,KAAKvQ,MAC/BmK,WAAYnK,KAAKyD,MAAMiO,UACvBtH,SAAUpK,KAAKyD,MAAM6N,OAAQ2C,WAAWhT,MAAM,MAAMjB,KAAKyD,MAAMiO,UAAY,KAG9D,cAAC,GAAD,CAAYlD,UAAWxO,KAAKgU,UAAUzD,KAAKvQ,U,4BAW9D,WAA+B,IAAD,OAC5B,OAAO,qBAAK2N,UAAU,mBAAf,SACJ3N,KAAKyD,MAAM+N,SACR,gCACA,6BACGxR,KAAKyD,MAAMgO,cAEbzR,KAAKkU,gBAEN,cAAC,GAAD,CACAhD,SAAUlR,KAAKyD,MAAM2N,SACrBzB,MAAO3P,KAAKmU,UAAU5D,KAAKvQ,MAC3B0P,cAAe,kBAAM,EAAKF,SAAS,KACnCC,kBAAmBzP,KAAKyP,kBAAkBc,KAAKvQ,MAC/C6P,mBAAoB7P,KAAK6P,mBAAmBU,KAAKvQ,Y,0BAYzD,WACE,OACE,cAAC,IAAD,CACEoU,gBAAgB,SAChBC,aA/PS,qcAgQTC,QAAStU,KAAKuU,qBAAqBhE,KAAKvQ,MACxCkI,MAAM,QACNsM,QAAS,CACPC,QAAS,CACPC,SAAS,GAEXC,SAAU,IAEZC,iBAAiB,mB,0BAQvB,WACE,OACE,0BACEjH,UAAU,iBACV5L,MAAO/B,KAAKyD,MAAM+B,OAClBqP,UAAQ,M,oBAKd,WAAuB,IAAD,OACpB,OACE,sBAAKlH,UAAU,UAAf,UACE,yBAAQA,UAAU,iBAAlB,UACG3N,KAAK8U,mBACJ,QACA9U,KAAK+U,QAAQxE,KAAKvQ,OAClB,kBAA+B,MAAzB,EAAKyD,MAAM4N,cAElBrR,KAAK8U,mBACJ,SACA,kBAAM,EAAKE,QAAQ,EAAKvR,MAAM6N,OAAQ2C,eACtC,kBAAM,EAAKxE,uBAEZzP,KAAK8U,mBACJ,OACA,kBAAM,EAAKnF,MAAM,EAAKlM,MAAM6N,OAAQ2C,eACpC,kBAAM,EAAKxE,uBAEZzP,KAAK8U,mBACJ,YACA9U,KAAKiV,YAAY1E,KAAKvQ,OACtB,kBAAM,EAAKkV,uBAEZlV,KAAK8U,mBACJ,SACA9U,KAAKmV,SAAS5E,KAAKvQ,OACnB,kBAAM,EAAKyP,uBAEZzP,KAAK8U,mBACJ,OACA9U,KAAKoV,WAAW7E,KAAKvQ,OACrB,kBAAM,QAGV,sBAAK2N,UAAU,eAAf,UACG3N,KAAKqV,iBACLrV,KAAKsV,eACLtV,KAAKuV,uB,4DAMd,WAAclE,GAAd,sBAAAlR,EAAA,sEACkBkR,EADlB,OACQmE,EADR,YAEUA,EAAE5U,KAFZ,OAGS,sBAHT,OAMS,uBANT,8BAIMwO,MAAMoG,EAAE9O,QAJd,mBAKa,GALb,cAOM1G,KAAKwP,SAAS,CAAC6B,WAAYmE,IAC3BA,EAAE3O,cAAc1B,KAAhB,sBAAqB,sBAAAhF,EAAA,sDACnBiP,MAAM,uBACN,EAAKI,SAAS,CAAC6B,WAAY,MAA3B,sBAAkC,sBAAAlR,EAAA,sEAC1B,EAAKsV,QAAQjO,KADa,OAEhC4H,MAAM,sBAF0B,4CAFf,4CAR3B,mBAea,GAfb,iD,uFA4BA,SAAmBsG,GAA4B,IAAD,EACtCpE,EAAStR,KAAKyD,MAAM6N,OAC1B,GAAc,MAAVA,EAAJ,CAKA,IAAMqE,EAAYrE,EAAOsE,eACzB,GAAiB,MAAbD,EAAJ,CAIA,IAAMlD,EAAWkD,EAAUE,cACrBnC,EAAuB,CAC3BR,gBAAiBT,EAAStI,WAC1BgJ,cAAeV,EAAStI,WACxB2I,YAAaL,EAASI,OACtBI,UAAWR,EAASI,QAEtB,UAAAvB,EAAOwE,kBAAP,SAAmBC,mBACjB,CAACJ,GACD,CACE,CACEjC,QACAjO,KAAMiQ,KAGV,SAACnV,GAAD,OAAO,QAET+Q,EAAO0E,aApBL5G,MAAM,0BANNA,MAAM,0B,wBA6BV,WACEpP,KAAKwP,SAAS,CAACgC,UAAU,M,uBAG3B,WACExR,KAAKwP,SAAS,CAACgC,UAAU,M,4DAG3B,sBAAArR,EAAA,sEACcH,KAAKyV,QAAQpO,KAD3B,iDAEUrH,KAAKyV,QAAQxO,KAFvB,gD,yFAMA,WACE,IAAMqK,EAAStR,KAAKyD,MAAM6N,OACpB2E,EAAMjW,KAAKyD,MAAMkO,eACZ,MAAPsE,IACFjW,KAAKgU,YACL1C,EAAO4E,iBAAiBD,EAAK,IAC7BjW,KAAKwP,SAAS,CACZmC,eAAgB,U,2DAKtB,WAAazR,GAAb,oBAAAC,EAAA,6DAEEH,KAAKwP,SAAS,IAFhB,SAIQtP,EAAa8C,SAAQ,SAAAwC,GACzB,OAAQA,EAAO5E,MACb,IAAK,eACH,EAAK4O,SAAS,CACZhK,OAAQA,EAAO3E,YACf4Q,YAAa,KAEf,MACF,IAAK,eACHrR,QAAQC,IAAI,gBACZ,MACF,IAAK,eACH,GAAoB,sBAAhBmF,EAAOhE,KAA8B,CACvCpB,QAAQC,IAAImF,EAAO/D,SACnB,IACM0U,EADS,EAAK1S,MAAM6N,OACG4E,iBAAiB,GAC5C,CACE,CACExC,MAAO,IAAInC,IAAa/L,EAAOlE,KAAM,EAAGkE,EAAOlE,KAAM,GACrDkT,QAAS,CACP4B,aAAa,EACbzI,UAAW,gCAKnB,EAAK6B,SAAS,CACZiC,YAAa,iBAAmBjM,EAAOlE,KAAO,MAAQkE,EAAOhE,KAAO,KAAOgE,EAAO/D,QAClFiQ,UAAWlM,EAAOlE,KAClBqQ,eAAgBwE,IAElB,EAAKf,kBAnCf,OAyCEpV,KAAKwP,SAAS,IAzChB,gD,mHA4CA,WAAchL,GAAd,SAAArE,EAAA,6DACEC,QAAQC,IAAI,WACZL,KAAK+R,wBAFP,KAGQ/R,KAHR,SAG0BA,KAAKyD,MAAM4N,WAAYzK,SAASyP,MAAM7R,GAHhE,wCAGa8R,OAHb,gE,iHAMA,WAAY9R,GAAZ,SAAArE,EAAA,6DACEC,QAAQC,IAAI,SACZL,KAAK+R,wBAFP,KAGQ/R,KAHR,SAG0BA,KAAKyD,MAAM4N,WAAYzK,SAAS2P,QAAQ/R,GAHlE,wCAGa8R,OAHb,gE,qHAUA,WAAgB9R,GAAhB,SAAArE,EAAA,6DACEC,QAAQC,IAAI,aADd,SAEeL,KAAKyD,MAAM4N,WAAYzK,SAAS2P,QAAQ/R,GAFvD,wF,oHAKA,sBAAArE,EAAA,6DACEC,QAAQC,IAAI,YACZL,KAAK+R,wBAFP,KAGQ/R,KAHR,SAG0BA,KAAKyD,MAAM4N,WAAYzK,SAAS4P,SAH1D,wCAGaF,OAHb,gE,sHAMA,sBAAAnW,EAAA,sEACQH,KAAKyD,MAAM4N,WAAYzK,SAAS6P,YADxC,OAIEzW,KAAKwP,SAAS,IAJhB,gD,2DAldoBqB,IAAMC,W,OC3C5B4F,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.6d258750.chunk.js","sourcesContent":["import { ConnectedMicrobitInteract } from '../impl/interact';\n\n/**\n * A description of connection failure\n*/\nexport interface FailedConnection {\n  readonly kind: 'ConnectionFailure',\n  readonly type: 'Failed to Obtain Port' | 'Failed to Open Port' | 'Port No Response'\n  readonly reason: string\n}\n\nexport interface MicrobitConnection {\n  readonly kind: 'MicrobitConnection'\n  /**\n   * An object that allows us to interact with the connected micro:bit.\n   */\n  readonly interact: ConnectedMicrobitInteract\n\n  /**\n   * A promise that completes when the micro:bit connection is no longer active.\n   * This promise itself does not try to disconnect micro:bit.\n   */\n  readonly disconnection: Promise<void>\n}\n\nexport enum MicrobitState{\n  /**\n   * Nothing is running,\n   * \n   * Allowed: flash/execute/reboot\n   * \n   * Not Allowed: interrupt\n   */\n  Free,\n  /**\n   * Code is running,\n   * \n   * Allowed: Interrupt\n   * \n   * Not Allowed: flash/execute/reboot\n   */\n  Busy\n}\n\n/**\n * Data that we expect to receive from micro:bit as a result of execututing the flashed code.\n */\nexport type MicrobitOutput = NormalOutput | ErrorMessage | ResetPressed\n\n/**\n * A piece of content that is output to the standard output of micro:bit.\n */\nexport interface NormalOutput {\n  readonly kind: 'NormalOutput'\n  /**\n   * outputChunk is a new piece of output we have obtained from micro:bit,\n   * and may not correspond to a single print() executed on the device.\n   */\n  readonly outputChunk: string\n}\n\n/**\n * An object indicate reset button is pressed on the microbit\n * \n * OutputStream will continue to output\n */\nexport interface ResetPressed{\n  readonly kind: 'ResetPressed'\n}\n\nexport type MicroPythonExceptionType = 'AssertionError'\n  | 'AttributeError'\n  | 'Exception'\n  | 'ImportError'\n  | 'IndexError'\n  | 'KeyboardInterrupt'\n  | 'KeyError'\n  | 'MemoryError'\n  | 'NameError'\n  | 'NotImplementedError'\n  | 'OSError'\n  | 'RuntimeError'\n  | 'StopIteration'\n  | 'SyntaxError'\n  | 'SystemExit'\n  | 'TypeError'\n  | 'ValueError'\n  | 'ZeroDivisionError'\n  | 'IndentationError'\n\n/**\n * A description of a runtime error that occured on micro:bit\n */\nexport interface ErrorMessage {\n  readonly kind: 'ErrorMessage'\n  /**\n   * A integer indicating in which line of user code the error occurs\n   */\n  readonly line: number\n  /**\n   * A string indicating type of the exception\n   * For full list of types, see\n   * https://docs.micropython.org/en/latest/library/builtins.html#exceptions\n   */\n  readonly type: MicroPythonExceptionType\n  /**\n   * A *simple* explanation of the error\n   */\n  readonly message: string\n}\n","//TODO: Rename\n\nexport interface ManagerOption {\n  /**\n   * Parameter used to connect serial port. See `SerialOptions`\n   */\n  connectOption: SerialOptions\n  /**\n   * Parameter used for filtering serial port. See `SerialPortRequestOptions`\n   */\n  requestOption: SerialPortRequestOptions\n  /**\n   * Parameter used for reader class\n   */\n  readOption: readOption\n  /**\n   * Parameter used for parser class\n   */\n  signalOption: SignalOption\n}\n\nexport interface readOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * Program output should be updated to the web every `updateMs` ms.\n   */\n  updateMs: number\n  /**\n   * Length of program output that should be kept.\n   * \n   * It is recommended to set this to 2 * maximum number of character in the textarea.\n   */\n  cutLength: number\n}\n\nexport interface SignalOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating waiting for user input code\n   */\n  replLineReady: string,\n  /**\n   * A string to be printed by `print` statement\n   * Before execution of user code\n   * Outputting is implemented by adding print statement before user code\n   */\n  executionStart: string,\n  /**\n   * A string to be printed by `print` statement \n   * After execution of given user code\n   * Outputting is implemented by adding print statement after user code\n   */\n  executionDone: string,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating an error occured\n   */\n  mainPYException: string,\n  execException: string,\n  /**\n   * Ms before microbit is rebooted to run `main.py`\n   * Allowing output buffer to be emptied before reboot\n   * \n   * Not used right now\n   */\n  waitMsBeforeReboot: number,\n}\n\nexport const defaultConfig: ManagerOption = {\n  connectOption: {\n    baudRate: 115200,\n    dataBits: 8,\n    stopBits: 1,\n    parity: 'none',\n    bufferSize: 4096,\n    flowControl: 'none'\n  },\n  requestOption: {\n    filters: [\n      { usbVendorId: 0x0d28 }\n    ]\n  },\n  readOption: {\n    showLog: true,\n    updateMs: 50,\n    cutLength: 1000\n  },\n  //maybe consider using regexp?\n  signalOption: {\n    showLog: true,\n    replLineReady: '>>> ',\n    executionDone: 'Execute Done: 0x3f3f3f3f',\n    executionStart: 'Execution Start: 0x3f3f3f3f',\n    mainPYException: 'Traceback (most recent call last):\\r\\n  File \"main.py\", line ',\n    execException:   'Traceback (most recent call last):\\r\\n  File \"<stdin>\", line 1, in <module>\\r\\n  File \"<string>\", line ',\n    waitMsBeforeReboot: 1\n  }\n};","import Stream from 'ts-stream';\nimport { MicrobitOutput, MicroPythonExceptionType } from '../../interface/message';\nimport { SignalOption } from '../../interface/config';\nimport { SerialReader } from './reader';\n\n/**\n * This class provides functions to read serial output of a specific procedure,\n * by using the reader helper class.\n *\n * Below is its mechanism. Based on following input of code\n * ```\n * 1|Get REPL Line|>>>\n * 2|Setup Code   |>>> file=open('main.py','w');s='print(executionStart)\\\\r\\\\nprint(1)\\\\r\\\\nprint(executionStart)';file.write(s);file.close();from microbit import *;sleep(0);reset();\n * 3|#Byte Written|8\n * 4|executionStart\n * 5|Code output  |1\n * 6|executionDone\n * 6|MicroPython v1.13 on 2021-02-19; micro:bit v2.0.0-beta.4 with nRF52833\n * 7|Type \"help()\" for more information.\n * 8|>>>\n * ```\n *\n * Error Sample (Flashing)\n * ```\n * Traceback (most recent call last):\n * File \"main.py\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n *\n * REPL Sample (Running)\n * ```\n * Traceback (most recent call last):\n * File \"<stdin>\", line 1, in <module>\n * File \"<string>\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n */\nexport class SerialParser {\n  portReader: SerialReader;\n  config: SignalOption;\n  startSignals: string[];\n  endSignals: string[];\n\n  constructor(portReader: SerialReader, config: SignalOption) {\n    this.portReader = portReader;\n    this.config = config;\n    this.startSignals = [\n      config.executionStart + '\\r\\n',\n      config.mainPYException,\n      config.execException\n    ];\n    this.endSignals = [\n      config.executionDone + '\\r\\n',\n      config.executionStart + '\\r\\n',\n      config.mainPYException,\n      config.execException\n    ];\n\n  }\n\n  /**\n   * Read until new repl line is ready\n   */\n  readUntilNewReplLine(): Promise<void> {\n    return this.portReader.safeReadUntil(this.config.replLineReady);\n  }\n\n  /**\n   * Read until executionStart appears on serial\n   * - If there is no error, this Returns true\n   * - If (indentation/bracket) error occurs, the stream will be closed and false is returned\n   */\n  async readUntilExecStart(outputStream: Stream<MicrobitOutput>): Promise<boolean> {\n    if (this.config.showLog) console.log('Waiting for Execution Start');\n    const result = await this.portReader.safeReadUntilWithUpdate(\n      this.startSignals,\n      _ => null\n    );\n    if (result !== 0) {\n      this.readErrors(outputStream);\n      return false;\n    } else return true;\n  }\n\n  /**\n   * Read output of user code, periodically update output to stream\n   *\n   * Require executeStart printed earlier\n   */\n  async readUntilExecDone(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    if (this.config.showLog) console.log('Execution Start');\n    // Now user code will run\n    // read until executionEnd signal appear on signal\n    let result = 1;\n    while (result === 1) {\n      result = await this.portReader.safeReadUntilWithUpdate(\n        this.endSignals,\n        str => outputStream.write({\n          kind: 'NormalOutput',\n          outputChunk: str\n        })\n      );\n      if (result === 1) outputStream.write({\n        kind: 'ResetPressed'\n      });\n    }\n    if (result !== 0) await this.readErrors(outputStream);\n    if (this.config.showLog) console.log('Execution done');\n  }\n\n  /**\n   * Read and parse micropython error output\n   */\n  async readErrors(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    if (this.config.showLog) console.log('Execution Error');\n    // line1 indicates in which line of user code exception occurred\n    // which is first line after mainPYException and execException\n    const line1 = await this.portReader.unsafeReadline();\n    const lineNumberString = line1.split(',', 2)[0];\n    // messageLine is in the form of 'ErrorType:ErrorMessage'\n    // exec is used in user code, the line following line1 may not be messageLine\n    let lineCount = 0;\n    let messageLine = '';\n    while (lineCount === 0 || messageLine.startsWith('  ')) {\n      messageLine = await this.portReader.unsafeReadline();\n      lineCount += 1;\n    }\n    const line2split = messageLine.split(': ');\n    outputStream.write({\n      kind: 'ErrorMessage',\n      line: parseInt(lineNumberString) - 1,\n      type: line2split[0] as MicroPythonExceptionType,\n      message: (line2split.length === 1) ? '' : line2split[1]\n    });\n  }\n}","import { readOption } from '../../interface/config';\n\n/**\n * This class provide convenient function for reading serial output.\n */\nexport class SerialReader {\n  private serialBuffer = ''\n  private portReader: ReadableStreamDefaultReader<string>\n  private config: readOption\n\n  constructor(portReader: ReadableStreamDefaultReader<string>, config: readOption) {\n    this.portReader = portReader;\n    this.config = config;\n  }\n\n  /**\n   * Read from serial until termination is true.\n   *\n   * Buffer will not be cut in this function.\n   */\n  private async readLoop(termination: (text: string) => boolean): Promise<void> {\n    if (this.config.showLog) console.log(this.serialBuffer);\n    while (!termination(this.serialBuffer)) {\n      const {value} = await this.portReader.read();\n      this.serialBuffer += value;\n      if (this.config.showLog) console.log(this.serialBuffer);\n    }\n  }\n\n  /**\n   * Read from serial until termination is true.\n   *\n   * Assuming only last *bufferLimit* characters decides termination,\n   * this readLoop cuts unnecessary part of the buffer\n   */\n  private async readLoopWithCut(termination: (text: string) => boolean, bufferLimit: number): Promise<void> {\n    if (this.config.showLog) console.log(this.serialBuffer);\n    while (!termination(this.serialBuffer)) {\n      const len = this.serialBuffer.length;\n      if (len >= bufferLimit) this.serialBuffer = this.serialBuffer.substring(len - bufferLimit);\n      const {value} = await this.portReader.read();\n      this.serialBuffer += value;\n      if (this.config.showLog) console.log(this.serialBuffer);\n    }\n  }\n\n  /**\n   * Split *buffer* on first occurrence of token.\n   *\n   * PRE: buffer = before + token + after\n   * buffer = after\n   * return before\n   */\n  private splitBufferOnFirst(token: string): string {\n    const index = this.serialBuffer.indexOf(token);\n    const before = this.serialBuffer.substr(0, index);\n    this.serialBuffer = this.serialBuffer.substr(index + token.length);\n    return before;\n  }\n\n  /**\n   * This function read a line from serial,\n   * and returns that line.\n   *\n   * You should only use this function when you are certain about what's coming from serial.\n   */\n  async unsafeReadline(): Promise<string> {\n    const token = '\\r\\n';\n    await this.readLoop(str => str.includes(token));\n    return this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until token appears in serial output, and returns nothing.\n   *\n   * Reading is optimized by cutting unnecessary string,\n   * so length of buffer < length of token.\n   *\n   * This is useful when reading potential long output,\n   * and the content before token does not matter\n   */\n  async safeReadUntil(token: string): Promise<void> {\n    await this.readLoopWithCut(str => str.includes(token), token.length);\n    this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until one of the token from the token array appears in serial output,\n   * and returns the token that appear in serial.\n   * Its content is also periodically updates to upstream and when the token appears.\n   *\n   * This is useful when reading potential long output,\n   * and recent content of some length matters.\n   *\n   * Consider the following cases, which make the implementation necessary.\n   *\n   * `while True: print(1)`\n   * A lot of output\n   *\n   * `a=input(\"You name:\")`\n   * New content only come out after every thing gets outputted\n   * (So user can input)\n   */\n  async safeReadUntilWithUpdate(tokens: Array<string>, update: (text: string) => void): Promise<number> {\n    let bufferUpdated = false;\n    let matchedTokenID = -1;\n    const termination = (str: string) => {\n      bufferUpdated = true;\n      tokens.forEach((token, index) => {\n        if (str.includes(token)) matchedTokenID = index;\n      });\n      return matchedTokenID !== -1;\n    };\n    const updateTimer = setInterval(() => {\n      if (bufferUpdated) {\n        update(this.serialBuffer);\n        bufferUpdated = false;\n      }\n    }, this.config.updateMs);\n    await this.readLoopWithCut(termination, this.config.cutLength);\n    clearInterval(updateTimer);\n    update(this.splitBufferOnFirst(tokens[matchedTokenID]));\n    return matchedTokenID;\n  }\n}\n","import Stream from 'ts-stream';\nimport { SerialParser } from './helper/parser';\nimport { SerialReader } from './helper/reader';\nimport { MicrobitOutput, MicrobitState } from '../interface/message';\nimport { ManagerOption, SignalOption } from '../interface/config';\n\nconst ctrlC = '\\x03';\n\nexport class ConnectedMicrobitInteract {\n  port: SerialPort;\n  portWriter!: WritableStreamDefaultWriter<string>;\n  portReader!: ReadableStreamDefaultReader<string>;\n  portParser!: SerialParser\n  signal: SignalOption;\n  state: MicrobitState;\n\n  readonly portWriterStreamClosed: Promise<void> | null = null;\n  readonly portReaderStreamClosed: Promise<void> | null = null;\n\n  constructor(port: SerialPort, config: ManagerOption) {\n    this.port = port;\n    this.signal = config.signalOption;\n    this.state = MicrobitState.Free;\n    if (port.writable != null) {\n      const encoder = new TextEncoderStream();\n      this.portWriterStreamClosed = encoder.readable.pipeTo(port.writable)\n        .catch((_) => {\n          console.log('disconnected in pipe');\n        });\n      this.portWriter = encoder.writable.getWriter();\n    }\n    if (port.readable != null) {\n      const decoder = new TextDecoderStream();\n      this.portReaderStreamClosed = port.readable.pipeTo(decoder.writable)\n        .catch((_) => {\n          console.log('disconnected in pipe');\n        });\n      this.portReader = decoder.readable.getReader();\n\n      const portReaderHelper = new SerialReader(this.portReader, config.readOption);\n      this.portParser = new SerialParser(portReaderHelper, config.signalOption);\n    }\n  }\n\n  getState(): MicrobitState {\n    return this.state;\n  }\n\n  /**\n   * Convert a javascript string of python code to readable python code\n   */\n  private codeToPythonString(code: string): string {\n    /* \n    replaceAll From up to down\n      (1) user-used escape character. e.g. [\\][t]\n        This should still be [\\][t] in main.py\n        [\\][\\][t] in python string\n      (2) user-used [']\n        Because code is wrapped with ''\n        [\\]['] in python string\n      (3) new line created by user\n        Should be [\\r][\\n] in main.py\n        [\\][r][\\][n] in python string\n    */\n    return (\n      'print(\\'' + this.signal.executionStart + '\\')'\n      + '\\r\\n' + code + '\\r\\n'\n      + 'print(\\'' + this.signal.executionDone + '\\')'\n    ).replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, '\\\\\\'')\n      .replace(/\\r?\\n/g, '\\\\r\\\\n');\n  }\n\n  /**\n   * Send ctrlC to stop code execution\n   * - If no code was running, new REPL line starts\n   * - If code was running, then keyboardInterrupt appears\n   *    Serial input unavailable for a few ms, then new REPL line starts.\n   * Returns when the REPL line is clean and usable\n   */\n  private async getREPLLine(): Promise<void> {\n    await this.portWriter.write(ctrlC);\n    await this.portParser.readUntilNewReplLine();\n  }\n\n  /**\n   * Flash ROM of the connected micro:bit.\n   *\n   * The flashing consists of two stages of flashing the code followed by a reboot.\n   * The promise completes when reboot is done, resulting in a stream of outputs from microbit.\n   */\n  async flash(code: string): Promise<Stream<MicrobitOutput>> {\n    /*Whole procedure with workaround note\n      - Get a clean REPL line, see getREPLLine()\n      - Send code to `main.py` to REPL\n          Observation: Microbit serial lose characters when multiple lines are inputted\n          Workaround: Put all code on one line\n          The logic might be:\n            Microbit does not have enough pin on the chip for serial hardware flow control.\n            So computer has no way of knowing microbit buffer is full.\n            And when the buffer is full, microbit serial start to lose character.\n\n            When all code is on one line, microbit does not do any hard work until \\r entered\n            Less likely for the buffer to be full and lose character\n      - Print(replDone)\n          On receiving replDone, manager knows microbit finished writing to main.py\n          It is rebooting and all later output are program output\n    */\n    if (this.state === MicrobitState.Busy) throw Error('Flash Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'file=open(\\'main.py\\',\\'w\\');'\n      + 's=\\'' + codeInPythonString + '\\';'\n      + 'file.write(s);'\n      + 'file.close();'\n      + 'from microbit import *;'\n      + 'reset()\\r'\n    );\n    if (await this.portParser.readUntilExecStart(outputStream)) {\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => {\n          this.state = MicrobitState.Free;\n        })\n        .finally(() => {\n          outputStream.end();\n        });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  /**\n   * Run code in REPL.\n   * Microbit is not rebooted. So all previous variables are kept.\n   */\n  async execute(code: string): Promise<Stream<MicrobitOutput>> {\n    if (this.state === MicrobitState.Busy) throw Error('Execute Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      's=\\'' + codeInPythonString + '\\';'\n      + 'exec(s)\\r'\n    );\n    if (await this.portParser.readUntilExecStart(outputStream)) {\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => {\n          this.state = MicrobitState.Free;\n        })\n        .finally(() => {\n          outputStream.end();\n        });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  async getCompletions(prefix: string): Promise<string[]> {\n    if (this.state === MicrobitState.Busy) throw Error('Autocomplete Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    const endMarker = 'END MARKER';\n    let output = '';\n\n    await this.getREPLLine();\n    await this.portWriter.write(`${prefix}\\t`);\n    await this.portWriter.write(endMarker);\n    await this.portParser.portReader.safeReadUntilWithUpdate(\n      [endMarker],\n      (text) => output = text,\n    );\n    await this.getREPLLine();\n\n    this.state = MicrobitState.Free;\n    const lines = output.split(/\\n/g);\n    if (lines.length === 1) {\n      const text = lines[0];\n      // No completions found\n      if (text === prefix) return [];\n      // Identified exactly one completion\n      else return [text];\n    }\n    const completions: string[] = [];\n    for (const line of lines.slice(1, -1)) {\n      for (const completion of line.trim().split(/\\s+/g)) {\n        if (completion.length > 0)\n          completions.push(completion.trim()); // I miss concatMap\n      }\n    }\n    return completions;\n  }\n\n  /**\n   * Reboots the connected micro:bit.\n   * The promise completes with a stream of outputs from microbit.\n   */\n  async reboot(): Promise<Stream<MicrobitOutput>> {\n    if (this.state === MicrobitState.Busy) throw Error('Reboot Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'from microbit import *;'\n      + 'reset()\\r'\n    );\n    const outputStream = new Stream<MicrobitOutput>();\n    if (await this.portParser.readUntilExecStart(outputStream)) {\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => {\n          this.state = MicrobitState.Free;\n        })\n        .finally(() => {\n          outputStream.end();\n        });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  private waitUntil(cond: () => boolean): Promise<void> {\n    return new Promise((resolve, _) => {\n      const timer = setInterval(() => {\n        if (cond()) {\n          clearInterval(timer);\n          resolve();\n        }\n      }, 200);\n    });\n  }\n\n  /**\n   * Send an interrupt signal the connected micro:bit.\n   * This will try to stop any python code running on the micro:bit.\n   *\n   * The promise completes when the interruption is successful.\n   * If code is being executed, then there should be a ErrorMessage in the outputStream.\n   */\n  async interrupt(): Promise<void> {\n    if (this.state === MicrobitState.Free) throw Error('Interrupt Failed: Device not running code');\n    await this.portWriter.write(ctrlC);\n    await this.waitUntil(() => this.state === MicrobitState.Free);\n    //Not reading for new REPL line here\n    //because portParser might already be reading.\n  }\n\n  /**\n   * Disconnect the paired micro:bit.\n   */\n  async disconnect(): Promise<void> {\n    console.log('Disconnection initiated:');\n\n    await this.portReader.cancel('App will unmount');\n    await this.portReaderStreamClosed;\n    console.log('Reader closed;');\n\n    await this.portWriter.abort('App will unmount');\n    await this.portWriterStreamClosed;\n    console.log('Writer closed.');\n\n    await this.port.close();\n  }\n}","import { serial } from 'web-serial-polyfill';\nimport { defaultConfig, ManagerOption } from '../interface/config';\nimport { ConnectedMicrobitInteract } from './interact';\nimport { FailedConnection, MicrobitConnection } from '../interface/message';\n\n/**\n * Check if browser support WebSerial\n * Return true if WebSerial is supported\n * \n * If WebSerial is not supported but WebUSB is supported,\n * this function applys polyfill from Google.\n */\nexport function checkCompatability(): boolean {\n  if ('serial' in navigator) return true;\n  else {\n    if ('usb' in navigator) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (navigator as any).serial = serial;\n      return true;\n    } else return false;\n  }\n}\n\n/**\n * Given a unopenned serial port and configuration object,\n * Create a MicrobitConnection object\n */\nasync function createConnection(port: SerialPort, config: ManagerOption): Promise<MicrobitConnection | FailedConnection> {\n  try {\n    await port.open(config.connectOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Open Port',\n      reason: error.message\n    };\n  }\n  const portInteract = new ConnectedMicrobitInteract(port, config);\n  return {\n    kind: 'MicrobitConnection',\n    interact: portInteract,\n    disconnection: new Promise((resolve, _) => {\n      const onDisconnect = (_: Event) => {\n        console.log('disconnected');\n        port.removeEventListener('disconnect', onDisconnect);\n        resolve();\n      };\n      port.addEventListener('disconnect', onDisconnect);\n    })\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By selecting a serial port in the native permission window.\n * \n * **This must be followed by a UserGesture within a time period**\n * \n * *In some rare cases, calling other function before this can result in a UserGesture Error*\n */\nexport async function connectBySelection(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  let port: SerialPort;\n  try {\n    port = await navigator.serial.requestPort(config.requestOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Obtain Port',\n      reason: error.message\n    };\n  }\n  return createConnection(port, config);\n}\n\n/**\n * Create a MicrobitConnection object\n * By connecting to a paried serial device\n * This does not require selecting device in the native window.\n */\nexport async function connectByPariedDevice(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  const ports = await navigator.serial.getPorts();\n  if (ports.length === 1) return createConnection(ports[0], config);\n  else if(ports.length === 0) return {\n    kind: 'ConnectionFailure',\n    type: 'Failed to Obtain Port',\n    reason: 'No Paired Serial Devices Available'\n  }; else return {\n    kind: 'ConnectionFailure',\n    type: 'Failed to Obtain Port',\n    reason: 'Multiple Paired Serial Devices Available'\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By user plugging the device\n */\nexport async function connectByPlugIn(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  //Given serialPortInfo, check if it agrees with filters\n  function checkUSBInfo(info: SerialPortInfo, filters: SerialPortFilter[] | undefined): boolean {\n    if (filters === undefined) return true; //no constraint\n    else {\n      for (const f of filters) {\n        //for two property, no constraint or equal\n        if (f.usbProductId === undefined || f.usbProductId === info.usbProductId)\n          if (f.usbVendorId === undefined || f.usbVendorId === info.usbVendorId)\n            return true;\n      }\n      return false;\n    }\n  }\n  \n  return new Promise((resolve, _) => {\n    /**\n     * A event listener function\n     * Resolves the promise when a device is plugged in\n     */\n    const waitForPort = async(event: Event) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const port: SerialPort = (event as any).port || event.target;\n      if (checkUSBInfo(port.getInfo(), config.requestOption.filters)) {\n        navigator.serial.removeEventListener('connect', waitForPort);\n        resolve(createConnection(port, config));\n      }\n    };\n    //add the listener\n    navigator.serial.addEventListener('connect', waitForPort);\n  });\n}","export default __webpack_public_path__ + \"static/media/Duck.d495e477.jpg\";","/* eslint @typescript-eslint/no-var-requires: \"off\" */\n\nimport { Typography } from '@material-ui/core';\nimport Button from '@material-ui/core/Button';\nimport Grid from '@material-ui/core/Grid';\nimport { createMuiTheme, makeStyles } from '@material-ui/core/styles';\nimport { ThemeProvider } from '@material-ui/styles';\nimport Fuse from 'fuse.js';\nimport PropTypes from 'prop-types';\nimport { default as React, useState } from 'react';\nimport * as Space from 'react-spaces';\nimport duck from './resources/Duck.jpg';\nimport './styles.css';\n\ntype DuckProps = {\n  closeDuck(): void,\n  lineNumber?: number,\n  lineText?: string\n}\n\ntype SlideButton = {\n  link: string,\n  text: string,\n  params: string[]\n}\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#ffcc00', // feel free to change this colour\n    }\n  },\n});\n\n\nconst useStyles = makeStyles( (theme) => ({\n  button: {\n    flexGrow: 1,\n    border: 1,\n    borderRadius: 3,\n    color: 'black',\n    height: 48,\n    padding: theme.spacing(2),\n    margin: 8,\n    textAlign: 'center',\n    textTransform: 'none'\n  },\n  xButton: {\n    color: 'white',\n    backgroundColor: '#ff0000',\n    height: 20,\n    padding: theme.spacing(2),\n    textAlign: 'center'\n  },\n  speech: {\n    flexGrow: 1,\n    border: 1,\n    borderRadius: 3,\n    color: 'black',\n    padding: theme.spacing(2),\n    margin: 8,\n    textAlign: 'left'\n  }\n}));\n\nlet prevSlideParams: string[] = [];\nconst jsonData = require('./resources/duck_flowchart.json');\nconst slideNames = Object.keys(jsonData);\n\nconst tutorials = {\n  'HelloWorld': \n`from microbit import *\ndisplay.scroll(\"Hello, World!\")`,\n  \n  'SimpleButtons': \n`from microbit import *\nimport music\n\nwhile True:\n    if button_a.is_pressed():\n        display.show(Image.MUSIC_QUAVER)\n        music.play(music.NYAN)\n    if button_b.is_pressed():\n        display.show(Image.MEH)\n        music.play(music.POWER_DOWN)\n\n    display.show(Image.COW)`\n};\n\nfunction executeCorrespondingCommand(commandString: string, props: DuckProps) {\n  if (commandString === 'link_to_tutorial_about_errors') {\n    return (\n      <a href=\"https://example.com/faq.html\" target=\"_blank\" rel=\"noreferrer\">\n        Tutorial about errors\n      </a>\n    );\n  }\n  else if (commandString === 'get_readable_diff') {\n    return readableDiffMessage(props);\n\n  }\n  else if (commandString === 'get_error_line_no_and_highlight') {\n    return readableErrorLineNumber(props);\n  }\n  else {\n    return commandString;\n  }\n} \n\nfunction readableErrorLineNumber(props: DuckProps) {\n  if (props.lineNumber) {\n    return (<div>\n      Your error is on line \n      {' ' + props.lineNumber}, \n      so I’ve highlighted that line in the editor. \n      What type of error is displayed?\n    </div>);\n  }\n  else {\n    return ('I cannot see your error message. Perhaps press \\'RUN\\' again, and double check that an error message is visible?');\n  }\n\n}\n\nfunction readableDiffMessage(props: DuckProps) {\n  if (props.lineNumber && props.lineText) {\n    const strippedCodeLine = props.lineText.trim();\n    const tutorial = tutorials[prevSlideParams[0] as keyof typeof tutorials];\n    const strippedTutorialLines = tutorial.split('\\n').map(x => x.trim());\n    const fuse = new Fuse(strippedTutorialLines, { includeMatches: true, isCaseSensitive: true });\n    const result = fuse.search(strippedCodeLine);\n    if (result.length > 0) {\n      const closestLine = result[0];\n      const highlights = highlightDiffLine(strippedCodeLine, closestLine.item);\n      return (<div>\n        The closest matching line in the tutorial is line {closestLine.refIndex + 1} which reads: <br />\n        {convert(closestLine.item, highlights[1])} <br />\n        whereas your line reads: <br />\n        {convert(strippedCodeLine, highlights[0])}\n      </div>);\n    }\n    else {\n      return ('Unfortunately, your line does not look like any of the lines in the tutorial.');\n    }\n  }\n  else return ('I cannot see your error message. Perhaps press \\'RUN CODE\\' again, and double check that an error message is visible?');\n}\n\n// This returns two arrays representing what indexes to highlight in writtenLine and perfectLine respectively\nfunction highlightDiffLine(writtenLine: string, perfectLine: string): [number[], number[]] {\n  let bugCatcher = false;  // For catching a small bug\n  const lengthWritten = writtenLine.length; const lengthPerfect = perfectLine.length;\n  const highlightsWritten = []; let iWritten = 0;\n  const highlightsPerfect = []; let iPerfect = 0;\n  while (iWritten < lengthWritten && iPerfect < lengthPerfect) {\n    if (writtenLine[iWritten] === perfectLine[iPerfect]) {\n      iWritten++;\n      iPerfect++;\n    }\n    else {\n      if (iWritten + 1 === lengthWritten || iPerfect + 1 === lengthPerfect) {\n        highlightsWritten.push(iWritten); iWritten++;\n        highlightsPerfect.push(iPerfect); iPerfect++;\n\n        // Small exception when final character of writtenLine is the same as final character of perfectLine\n        // but we've only reached the end of writtenLine\n        if (!(iPerfect + 1 === lengthPerfect)) {\n          bugCatcher = true;\n        }\n      }\n      else {\n        // Checks the next 10 characters of perfectLine for any matches with the slice of writtenLine\n        const locationPerfect: number | undefined = lookFor(writtenLine.slice(iWritten, iWritten + 2), perfectLine, iPerfect, 10);\n        // Checks the next 10 characters of writtenLine for any matches with the slice of perfectLine\n        const locationWritten: number | undefined = lookFor(perfectLine.slice(iPerfect, iPerfect + 2), writtenLine, iWritten, 10);\n        if (locationWritten) {\n          while (iWritten < locationWritten) { highlightsWritten.push(iWritten); iWritten++; }\n          iWritten += 2;\n          iPerfect += 2;\n        } else if (locationPerfect) {\n          while (iPerfect < locationPerfect) { highlightsPerfect.push(iPerfect); iPerfect++; }\n          iWritten += 2;\n          iPerfect += 2;\n        } else {\n          highlightsWritten.push(iWritten); iWritten++;\n          highlightsPerfect.push(iPerfect); iPerfect++;\n        }\n      }\n    }\n  }\n\n  while (iWritten < lengthWritten) {\n    highlightsWritten.push(iWritten);\n    iWritten++;\n  }\n  while (iPerfect < lengthPerfect) {\n    highlightsPerfect.push(iPerfect);\n    iPerfect++;\n  }\n\n  // Small bugfix, solution is to check the final characters to see if they're the same\n  if (bugCatcher && writtenLine[iWritten - 1] === perfectLine[iPerfect - 1]) {\n    highlightsWritten.pop();\n    highlightsPerfect.pop();\n  }\n\n  function lookFor(couple: string, long: string, iStart: number, lookAhead: number) {  // couple should be 2 characters long\n    for (let i = iStart; i !== iStart + lookAhead && i + 1 < long.length; i++) {\n      if (long[i] === couple[0] && long[i + 1] === couple[1]) { return i; }\n    }\n    return undefined;\n  }\n\n  return [highlightsWritten, highlightsPerfect];\n}\n\n// Returns line as a JSX.Element with the highlights indexes all highlighted\nfunction convert(line: string, highlights: number[]) {\n  const convertedLine = [];\n\n  for (let i = 0; i < line.length; i++) {\n    if (i === highlights[0]) {\n      highlights.shift();\n      convertedLine.push(<span>{\n        <Typography color='secondary' display=\"inline\">\n          {line[i]}\n        </Typography>\n      }</span>);\n    } else {\n      convertedLine.push(<span>{\n        <Typography display=\"inline\">\n          {line[i]}\n        </Typography>\n      }</span>);\n    }\n  }\n  return convertedLine;\n}\n\nfunction parseTextCommand(commandString: string, props: DuckProps) {\n  let parsedCommand: string|JSX.Element = commandString;\n  if (commandString.startsWith('{')) { \n    // must also then end with '}'\n    const rawCommand = commandString.slice(1, -1); // remove surrounding braces\n    parsedCommand = executeCorrespondingCommand(rawCommand, props);\n  }\n  return parsedCommand;\n}\n\nfunction parseSpeech(speech: string, props: DuckProps) {\n  const re = /(\\{[\\S\\s]+?\\})/g;\n  const splitSpeech = speech.split(re).filter(Boolean);\n  const parsedSpeech = splitSpeech.map(x => parseTextCommand(x, props));\n  return parsedSpeech;\n}\n\nfunction MakeButtons(initialSlide: string, props: DuckProps) {\n  const classes = useStyles();\n  const [slide, setSlide] = useState(initialSlide);  \n  // Here useState is a 'Hook' (from React) which means the slide variable is updated when the setSlide function is run\n\n  return (\n    <Space.Fixed height={600} width={600}>\n      <div>\n        <img src={duck} height={600} width={600} alt=\"cartoon duck\" />\n      </div>\n\n      <Space.Left size={60}></Space.Left>\n\n      <Space.Fill>\n        <Space.Top size={20}></Space.Top>\n        <Space.Fill>\n          <Space.Fill>\n            <Typography className={classes.speech}>\n              {parseSpeech(jsonData[slide].speech, props)}\n            </Typography>\n            <Grid container justify=\"center\" alignItems=\"flex-start\" spacing={2}>\n              {jsonData[slide].buttons.map(function (button: SlideButton) {\n                return (\n                  <div key={button.text}>\n                    <Grid item xs>\n                      <ThemeProvider theme={theme}>\n                        <Button\n                          className={classes.button}\n                          variant=\"contained\"\n                          color=\"primary\"\n                          onClick={() => {\n                            if (button.link) {\n                              // this checks button.link isnt null\n                              prevSlideParams = button.params;\n                              setSlide(button.link);\n                            } else {\n                              props.closeDuck();\n                            }\n                          }}\n                        >\n                          {button.text}\n                        </Button>\n                      </ThemeProvider>\n                    </Grid>\n                  </div>\n                );\n              })}\n            </Grid>\n          </Space.Fill>\n        </Space.Fill>\n        <Space.Bottom size={200}></Space.Bottom>\n      </Space.Fill>\n      <Space.Right size={250}>\n        <Space.Right size={430}>\n          <Space.Bottom size={600}>\n            <Button\n              className={classes.xButton}\n              variant=\"contained\"\n              size=\"small\"\n              onClick={() => {\n                props.closeDuck();\n              }\n              }\n            >\n              {'X'}\n            </Button>\n          </Space.Bottom>\n        </Space.Right>\n      </Space.Right>\n    </Space.Fixed>\n  );\n}\nMakeButtons.propTypes = {\n  closeDuck: PropTypes.func\n};\n\nexport default function StartSlides(props: DuckProps): JSX.Element {\n  return MakeButtons(slideNames[0], props);\n}","import React from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport './TutorialViewer.css';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { darcula } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { Button } from '@material-ui/core';\nimport { DoubleArrow, PlayArrow, Visibility, VisibilityOff } from '@material-ui/icons';\nimport { MicrobitOutput } from '../api/microbit/interface/message';\nimport { Stream } from 'ts-stream';\n\n\n/**\n * Readonly Python code cell, with buttons to:\n * - toggle between viewing the full {@link PythonCodeProps.code} and only the\n *   highlighted fragment, as specified by `# LINES {start}-{end}` (counting\n *   from 1 like humans do, both ends inclusive) on the first line of the code;\n * - execute the full {@link PythonCodeProps.code} using\n *   {@link PythonCodeProps.onRun} and display the output and error message, if\n *   {@link PythonCodeProps.hasFreeConnection} is true;\n * - insert the highlighted fragment into the editor using\n *   {@link PythonCodeProps.onInsertIntoEditor}.\n *\n * If this meta-comment is missing or not in the correct format, the toggle\n * views button will be hidden, and the highlighted fragment is the whole\n * code for the purpose of {@link PythonCodeProps.onInsertIntoEditor}.\n */\nclass PythonCode extends React.Component<PythonCodeProps, PythonCodeState> {\n  /**\n   * Whether the first line of {@link PythonCodeProps.code} is a comment\n   * specifying the extent of the highlighted fragment.\n   * If false, the toggle button is hidden away.\n   */\n  readonly isExpandable: boolean;\n\n  /**\n   * Starting index of the highlighted fragment in {@link lines},\n   * counting from 0, included.\n   * Defaults to 0.\n   */\n  readonly highlightStart: number;\n\n  /**\n   * Ending index of the highlighted fragment in {@link lines},\n   * counting from 0, excluded.\n   * Defaults to {@link lines}.length.\n   */\n  readonly highlightEnd: number;\n\n  /**\n   * The code split by new lines, stored here to avoid repeated computation.\n   */\n  readonly lines: string[];\n\n  /**\n   * The highlighted lines, AKA highlighted fragment, i.e.,\n   * {@link lines}[{@link highlightStart}, {@link highlightEnd}).\n   */\n  readonly highlightedLines: string[];\n\n  /**\n   * Parses the meta-comment specifying the highlighted fragment (if there is\n   * one), compute and set the readonly properties.\n   *\n   * The starting line number `x` and the ending line number `y` must satisfy:\n   * -   1 ≤ x, y ≤ {@link lines}.length\n   *   ==> 0 ≤ x < {@link lines}.length && 0 < y ≤ {@link lines}.length\n   * -   x ≤ y\n   *\n   * An alert is thrown if `# LINES` is matched at the start of the first line\n   * but `x` and `y` cannot be parsed or don't satisfy the conditions above\n   * (but not with e.g. `# LINES 1-2-3`).\n   * In this case, like when `# LINES` is not matched at the start of line 0,\n   * - {@link isExpandable} is set to false;\n   * - {@link highlightStart} is set to 0;\n   * - {@link highlightEnd} is set to {@link lines}.length.\n   */\n  // TODO unit test / use a proper parser\n  constructor(props: PythonCodeProps) {\n    super(props);\n\n    this.isExpandable = false;\n    this.lines = this.props.code.split('\\n');\n    this.highlightStart = 0;\n    this.highlightEnd = this.lines.length;\n\n    if (this.lines.length > 0) {\n      // Parse \"LINES x-y\".\n      const fragments = this.lines[0].split('# LINES ');\n      if (fragments.length === 2) { // '# LINES x-y' -> ['', 'x-y']\n        const lineNumbers = fragments[1].split('-');\n        const start = parseInt(lineNumbers[0]);\n        const end = parseInt(lineNumbers[1]);\n\n        function isLineNumberValid(lineNumber: number, name: string, maxValue: number): boolean {\n          if (isNaN(lineNumber)) {\n            alert(`Failed to parse ${name}: ${lineNumber}`);\n            return false;\n          }\n          if (lineNumber < 1) {\n            alert(`${name} must be at least 1: ${lineNumber}`);\n            return false;\n          }\n          if (lineNumber > maxValue) {\n            alert(`${name} must not exceed the biggest line number ${maxValue}`);\n            return false;\n          }\n\n          return true;\n        }\n\n        if (isLineNumberValid(start, 'Starting line', this.lines.length)\n          && isLineNumberValid(end, 'Ending line', this.lines.length)) {\n          if (start <= end) {\n            this.highlightStart = start - 1; // indexing from 0\n            this.highlightEnd = end - 1 + 1; // end included\n            this.isExpandable = true;\n          } else {\n            alert(`The starting line number must be at least the ending line number, but got ${start} < ${end}`);\n          }\n        }\n      }\n    }\n\n    this.highlightedLines = this.lines.slice(this.highlightStart, this.highlightEnd);\n\n    this.state = {\n      isExpanded: !this.isExpandable,\n      output: '',\n    };\n  }\n\n  /**\n   * Toggle between viewing the full example code and the highlighted fragment,\n   * by toggling {@link PythonCodeState.isExpanded}.\n   */\n  onToggleExpand(): void {\n    this.setState({isExpanded: !this.state.isExpanded});\n  }\n\n  /**\n   * Run the whole {@link PythonCodeProps.code}, clear the old output and store\n   * the normal output / error messages other than `KeyboardInterrupt` in\n   * {@link PythonCodeState.output} to be displayed.\n   * Upon termination, {@link PythonCodeProps.onRunFinished} is invoked to\n   * update the state of the app, so that the buttons are greyed out or re-\n   * enabled as appropriate.\n   */\n  async onRun(): Promise<void> {\n    this.setState({\n      output: '',\n    });\n    if (!this.props.hasFreeConnection()) {\n      alert('UI lied: Device is NOT free');\n      this.props.onRunFinished();\n      return;\n    }\n\n    const outputStream = await this.props.onRun(this.props.code);\n    let currentOutput = '';\n    await outputStream.forEach((output) => {\n      switch (output.kind) {\n        case 'NormalOutput':\n          currentOutput = output.outputChunk;\n          break;\n        case 'ErrorMessage':\n          if (output.type === 'KeyboardInterrupt') break;\n          currentOutput = `${currentOutput}Error on line ${output.line}:\n${output.type}: ${output.message}`;\n      }\n      this.setState({\n        output: currentOutput,\n      });\n    });\n    this.props.onRunFinished();\n  }\n\n  /**\n   * Insert the highlighted fragment {@link lines}[{@link highlightStart},\n   * {@link highlightEnd}) into the editor through\n   * {@link PythonCodeProps.onInsertIntoEditor}.\n   */\n  onInsertIntoEditor(): void {\n    this.props.onInsertIntoEditor(this.highlightedLines.join('\\n'));\n  }\n\n  /**\n   * Compute the displayed text.\n   *\n   * - If {@link PythonCodeState.isExpanded} is true, this is the entirety of\n   *   the {@link lines} (joined with new lines);\n   * - otherwise, this is the {@link highlightedLines} with `# ...` shown at\n   *   either end if there are lines of code folded there.\n   */\n  getDisplayedText(): string {\n    let lines;\n\n    if (this.state.isExpanded) {\n      lines = this.lines;\n    } else {\n      lines = this.highlightedLines;\n\n      if (this.highlightStart > 0) {\n        lines = ['# ...', ...lines];\n      }\n      if (this.highlightEnd < this.lines.length) {\n        lines = [...lines, '# ...'];\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * A quirky feature: line numbers are only shown when the full code is shown.\n   * (And when the the meta-comment is missing and the fragment is the whole\n   *  code, {@link PythonCodeState.isExpanded} is set to true, thus showing the\n   *  line numbers by default without offering the ability to toggle the view.)\n   *\n   * Incidentally, showing the line numbers makes it harder to copy the code:\n   * the line numbers are also copied. This could be a feature in that it\n   * prevents the students from copying code other than the lines that we wish\n   * to highlight and for them to insert into the editor.\n   */\n  render(): JSX.Element {\n    return <div>\n      <SyntaxHighlighter\n        style={darcula}\n        language=\"py\"\n        showLineNumbers={this.state.isExpanded}\n      >\n        {this.getDisplayedText()}\n      </SyntaxHighlighter>\n\n      <div className=\"Tutorial-code-buttonbar\">\n        <Button\n          className=\"Tutorial-code-buttons\"\n          variant=\"contained\"\n          color=\"primary\"\n          startIcon={<PlayArrow/>}\n          disabled={!this.props.hasFreeConnection()}\n          onClick={this.onRun.bind(this)}\n        >\n          Run Example\n        </Button>\n\n        {\n          this.isExpandable &&\n          <Button\n            className=\"Tutorial-code-buttons\"\n            variant=\"contained\"\n            endIcon={this.state.isExpanded ? <Visibility/> : <VisibilityOff/>}\n            onClick={this.onToggleExpand.bind(this)}\n          >\n            Full Code:\n          </Button>\n        }\n\n        <Button\n          className=\"Tutorial-code-buttons\"\n          variant=\"contained\"\n          color=\"secondary\"\n          endIcon={<DoubleArrow/>}\n          onClick={this.onInsertIntoEditor.bind(this)}\n        >\n          Insert Fragment\n        </Button>\n      </div>\n\n      {this.state.output.length > 0 &&\n      <div className=\"Tutorial-output\">\n        {this.state.output}\n      </div>\n      }\n    </div>;\n  }\n}\n\ninterface PythonCodeProps {\n  code: string,\n\n  onRun(code: string): Promise<Stream<MicrobitOutput>>,\n\n  onRunFinished(): void,\n\n  hasFreeConnection(): boolean,\n\n  onInsertIntoEditor(codeSnippet: string): void,\n}\n\n\ninterface PythonCodeState {\n  isExpanded: boolean,\n  output: string,\n}\n\n\n/**\n * Renders the tutorial from the supplied {@link TutorialViewerProps.markdown}.\n *\n * The code blocks in markdown are rendered with syntax highlighting.\n * In particular, code blocks whose language is 'py', such as\n *\n * ~~~py\n * print('Hello, world')\n * ~~~\n *\n * or\n *\n * ```py\n * print('Hello world!')\n * ```\n *\n * are rendered with\n * - a run button which, when enabled if\n *   {@link TutorialViewerProps.hasFreeConnection} returns true, runs the code\n *   in this code block with {@link TutorialViewerProps.onRun};\n * - an insert into editor button, which inserts (a subset of, see below) the\n *   code in this code block into the editor with\n *   {@link TutorialViewerProps.onInsertIntoEditor}.\n *\n * Furthermore, if the first line of code is a comment of the format\n * `# LINES x-y` where `x`, `y` are integers satisfying 0 ≤ `x` ≤ `y` ≤ #lines,\n * such as\n *\n * ~~~py\n * # LINES 1-2\n * print(1)\n * print(2)\n * print(3)\n * ~~~\n *\n * then by default only the code fragment is shown, and now a button to toggle\n * between showing the full code and only the highlighted fragment is\n * available.\n * Also, only the highlighted fragmented is inserted now; see\n * {@link PythonCode} for the details.\n *\n */\nexport default class TutorialViewer extends React.Component<TutorialViewerProps, unknown> {\n  renderCode(code: MarkdownCode): JSX.Element {\n    if (code.language === 'py') {\n      return <PythonCode\n        code={code.value}\n        onRun={this.props.onRun}\n        onRunFinished={this.props.onRunFinished}\n        onInsertIntoEditor={this.props.onInsertIntoEditor}\n        hasFreeConnection={this.props.hasFreeConnection}\n      />;\n    } else {\n      return <SyntaxHighlighter\n        style={darcula}\n        language={code.language}\n      >\n        {code.value}\n      </SyntaxHighlighter>;\n    }\n  }\n\n  renderers = {code: this.renderCode.bind(this)};\n\n  render(): JSX.Element {\n    return <ReactMarkdown className=\"Tutorial-markdown\" renderers={this.renderers}>\n      {this.props.markdown}\n    </ReactMarkdown>;\n  }\n}\n\ninterface TutorialViewerProps {\n  markdown: string,\n\n  onRun(code: string): Promise<Stream<MicrobitOutput>>,\n\n  onRunFinished(): void,\n\n  hasFreeConnection(): boolean,\n\n  onInsertIntoEditor(codeSnippet: string): void,\n}\n\ninterface MarkdownCode {\n  /** The language of the code block, specified by e.g. ```py ...``` */\n  language: string,\n  /** The contents of the code block */\n  value: string,\n}\n\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { Button } from '@material-ui/core';\nimport Editor, { loader, Monaco } from '@monaco-editor/react';\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport React from 'react';\nimport { Stream } from 'ts-stream';\nimport {\n  checkCompatability,\n  connectByPariedDevice,\n  connectByPlugIn,\n  connectBySelection\n} from '../api/microbit/impl/connect';\nimport { FailedConnection, MicrobitConnection, MicrobitOutput, MicrobitState } from '../api/microbit/interface/message';\nimport DuckViewer from '../duck-code';\nimport './APIDemo.css';\nimport TutorialViewer from './TutorialViewer';\n\ninterface APIDemoState {\n  /** The markdown of the tutorial being displayed. */\n  tutorial: string,\n  output: string,\n  connection: MicrobitConnection | null,\n  editor: monaco.editor.IStandaloneCodeEditor | null,\n  monaco: Monaco | null,\n  needDuck: boolean,\n  /** The most recent error message for the user, if one exists (otherwise, empty string) */\n  errorString: string,\n  errorLine: number,\n  errorMonacoIDs: string[] | null\n}\n\nconst exampleCode = `from microbit import *\nimport music\n\nwhile True:\n    if accelerometer.was_gesture('shake'):\n        display.show(Image.CONFUSED)\n        sleep(1500)\n    if accelerometer.was_gesture('face up'):\n        display.show(Image.HAPPY)\n    if accelerometer.was_gesture('left'):\n        display.show('<')\n        music.play(music.JUMP_UP)\n    if accelerometer.was_gesture('right'):\n        display.show('>')\n        music.play(music.JUMP_DOWN)\n`;\n\nclass APIDemo extends React.Component<unknown, APIDemoState> {\n  constructor(props: unknown) {\n    super(props);\n    this.state = {\n      tutorial: '# Fetching tutorial...',\n      output: '',\n      connection: null,\n      editor: null,\n      monaco: null,\n      needDuck: false,\n      errorString: '',\n      errorLine: 0,\n      errorMonacoIDs: null\n    };\n    if (!checkCompatability()) alert('Browser not supported');\n\n    loader.init().then(t => {\n      console.log(t);\n    });\n    this.removeErrorLineOfCode = this.removeErrorLineOfCode.bind(this);\n  }\n\n  /**\n   * Fetch a markdown file from `public/tutorials/` once mounted.\n   */\n  componentDidMount(): void {\n    fetch('tutorials/ErrorTute.md')\n      .then((r) => r.text())\n      .then((text) =>\n        this.setState({\n          tutorial: text,\n        }),\n      );\n  }\n\n  /**\n   * Called once the Monaco editor is mounted to set\n   * {@link APIDemoState.editor} and {@link APIDemoState.monaco}.\n   */\n  handleEditorDidMount(editor: monaco.editor.IStandaloneCodeEditor, monaco: Monaco): void {\n    this.setState({\n      editor: editor,\n      monaco: monaco,\n    });\n\n    const fetchCompletions = async (prefix: string) => {\n      if (this.hasFreeConnection()) {\n        console.log(`wat: ${prefix}`);\n        return this.state.connection!.interact.getCompletions(prefix);\n      } else return [];\n    };\n\n    monaco.languages.registerCompletionItemProvider(\n      'python',\n      {\n        triggerCharacters: ['_', '.', '(', '['],\n        async provideCompletionItems(model, position, _, __) {\n          const line = model.getLineContent(position.lineNumber);\n          let j = position.column - 1;\n          while (j >= 0 && line[j] !== ' ') j -= 1;\n          const startColumn = j + 1;\n          const word = line.slice(startColumn, position.column - 1);\n\n          const completions = await fetchCompletions(word);\n          // Two issues here:\n          // 1. 'help(d' -> 'help(display' --- need to replace the entire word\n          // 2. 'b' -> 'button_', to be completed again\n          if (completions.length === 1) {\n            const completion = completions[0];\n            const wordRange = {\n              startColumn: startColumn + 1,\n              endColumn: position.column,\n              startLineNumber: position.lineNumber,\n              endLineNumber: position.lineNumber,\n            };\n\n            // Deals with case 1\n            if (!completion.endsWith('_')) {\n              return {\n                suggestions: [{\n                  kind: monaco.languages.CompletionItemKind.Constant,\n                  label: completion,\n                  insertText: completion,\n                  range: wordRange,\n                }],\n              };\n            }\n\n            // Deals with case 2 (and 1)\n            return {\n              suggestions: [{\n                kind: monaco.languages.CompletionItemKind.Constant,\n                label: completion,\n                range: wordRange,\n                // hack to insert '_' to trigger another completion\n                insertText: completion.slice(0, -1),\n                // additionalTextEdits: [{\n                //   range: {},\n                //   text: '_',\n                // }],\n              }]\n            };\n          }\n          return {\n            suggestions: completions.map((suggestion) => {\n              return {\n                kind: monaco.languages.CompletionItemKind.Constant,\n                label: suggestion,\n                insertText: suggestion,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              } as any;\n            }),\n          };\n        }\n      },\n    );\n  }\n\n  /**\n   * @summary Disconnect the micro:bit before unmounting.\n   *\n   * For dev purposes only: upon recompilation, this component loses access to\n   * the {@link APIDemoState.connection} object; if the web serial connection\n   * is not terminated here, the page must needs to be refreshed to reclaim the\n   * micro:bit interface.\n   *\n   * In production, {@link APIDemo} is intended to be the top-level component\n   * to be dismounted only when the page is closed, after which the web serial\n   * connection is terminated anyways, making it unnecessary to manually invoke\n   * the disconnection procedure.\n   */\n  componentWillUnmount(): void {\n    this.state.connection?.interact.disconnect();\n  }\n\n  /**\n   * @summary Renders a button in the header of the app.\n   *\n   * The 'Start' button is enabled only when {@link APIDemoState.connection} is null,\n   * as it is intended to be used when:\n   * - the user first opens the page, and connects the micro:bit\n   * - the micro:bit is disconnected, and the user wants to reconnect it (or to\n   *   connect another one)\n   *\n   * {@link MicrobitState.Busy} and {@link MicrobitState.Free} document when\n   * the other micro:bit related buttons are enabled.\n   *\n   * The duck 'Help' button is always enabled.\n   */\n  renderHeaderButton(text: string, callback: () => void, isEnabled: () => boolean): JSX.Element {\n    const safeOnClickCallback = () => {\n      if (isEnabled()) {\n        callback();\n      } else {\n        alert(`UI lied: button ${text} should NOT be enabled`);\n        this.setState({});\n      }\n    };\n\n    return (\n      <Button\n        className=\"APIDemo-button\"\n        variant=\"contained\"\n        size=\"large\"\n        disabled={!isEnabled()}\n        onClick={safeOnClickCallback}\n      >\n        {text}\n      </Button>\n    );\n  }\n\n  /**\n   * Return true if the state of {@link APIDemoState.connection} is\n   * {@link MicrobitState.Free}, and false otherwise.\n   */\n  hasFreeConnection(): boolean {\n    return this.state.connection?.interact.getState() === MicrobitState.Free;\n  }\n\n  /**\n   * Return true if the state of {@link APIDemoState.connection} is\n   * {@link MicrobitState.Busy}, and false otherwise.\n   */\n  hasBusyConnection(): boolean {\n    return this.state.connection?.interact.getState() === MicrobitState.Busy;\n  }\n\n  renderDuck(): JSX.Element {\n    let renderedDuck;\n    if (this.state.errorString !== '') {\n      renderedDuck = <DuckViewer\n        closeDuck={this.exileDuck.bind(this)}\n        lineNumber={this.state.errorLine}\n        lineText={this.state.editor!.getValue().split('\\n')[this.state.errorLine - 1]}\n      />;\n    } else {\n      renderedDuck = <DuckViewer closeDuck={this.exileDuck.bind(this)}/>;\n    }\n    return renderedDuck;\n  }\n\n  /**\n   * Render {@link APIDemoState.tutorial} with {@link TutorialViewer} unless\n   * {@link APIDemoState.needDuck} is true, in which case\n   * {@link APIDemoState.errorString} and the duck (via {@link renderDuck}) are\n   * rendered instead.\n   */\n  renderTutorial(): JSX.Element {\n    return <div className=\"APIDemo-tutorial\">\n      {this.state.needDuck\n        ? <div>\n          <h1>\n            {this.state.errorString}\n          </h1>\n          {this.renderDuck()}\n        </div>\n        : <TutorialViewer\n          markdown={this.state.tutorial}\n          onRun={this.onRunCell.bind(this)}\n          onRunFinished={() => this.setState({})}\n          hasFreeConnection={this.hasFreeConnection.bind(this)}\n          onInsertIntoEditor={this.onInsertIntoEditor.bind(this)}\n        />\n      }\n    </div>;\n  }\n\n  /**\n   * Render the python code editor.\n   *\n   * The default code is {@link exampleCode}.\n   * The current code can be accessed via {@link APIDemoState.editor}.\n   */\n  renderEditor(): JSX.Element {\n    return (\n      <Editor\n        defaultLanguage=\"python\"\n        defaultValue={exampleCode}\n        onMount={this.handleEditorDidMount.bind(this)}\n        theme='light'\n        options={{\n          minimap: {\n            enabled: false,\n          },\n          fontSize: 18,\n        }}\n        wrapperClassName=\"APIDemo-code\"\n      />\n    );\n  }\n\n  /**\n   * Render a text box displaying {@link APIDemoState.output}.\n   */\n  renderOutput(): JSX.Element {\n    return (\n      <textarea\n        className=\"APIDemo-output\"\n        value={this.state.output}\n        readOnly\n      />\n    );\n  }\n\n  render(): JSX.Element {\n    return (\n      <div className=\"APIDemo\">\n        <header className=\"APIDemo-header\">\n          {this.renderHeaderButton(\n            'Start',\n            this.onStart.bind(this),\n            () => this.state.connection == null,\n          )}\n          {this.renderHeaderButton(\n            'Flash',\n            () => this.onFlash(this.state.editor!.getValue()),\n            () => this.hasFreeConnection(),\n          )}\n          {this.renderHeaderButton(\n            'Run',\n            () => this.onRun(this.state.editor!.getValue()),\n            () => this.hasFreeConnection(),\n          )}\n          {this.renderHeaderButton(\n            'Interrupt',\n            this.onInterrupt.bind(this),\n            () => this.hasBusyConnection(),\n          )}\n          {this.renderHeaderButton(\n            'Reboot',\n            this.onReboot.bind(this),\n            () => this.hasFreeConnection(),\n          )}\n          {this.renderHeaderButton(\n            'Help',\n            this.summonDuck.bind(this),\n            () => true,\n          )}\n        </header>\n        <div className=\"APIDemo-body\">\n          {this.renderTutorial()}\n          {this.renderEditor()}\n          {this.renderOutput()}\n        </div>\n      </div>\n    );\n  }\n\n  async connect(connection: Promise<MicrobitConnection | FailedConnection>): Promise<boolean> {\n    const c = await connection;\n    switch (c.kind) {\n      case 'ConnectionFailure':\n        alert(c.reason);\n        return false;\n      case 'MicrobitConnection':\n        this.setState({connection: c});\n        c.disconnection.then(async () => {\n          alert('Serial disconnected');\n          this.setState({connection: null}, async () => {\n            await this.connect(connectByPlugIn());\n            alert('Serial reconnected');\n          });\n        });\n        return true;\n    }\n  }\n\n  /**\n   * Insert the code snippet into {@link APIDemoState.editor} at the cursor.\n   * (If the user has never focused on the monaco editor before, the cursor is\n   * actually placed on the top left, so the snippet is inserted at the very\n   * start of the text.)\n   * Then, the cursor is placed after the inserted text which becomes selected.\n   * Also, the insertion operation is pushed onto the buffer and may be undone.\n   * Finally, the editor gets the focus.\n   */\n  onInsertIntoEditor(codeSnippet: string): void {\n    const editor = this.state.editor;\n    if (editor == null) {\n      alert('Editor is not loaded');\n      return;\n    }\n\n    const selection = editor.getSelection();\n    if (selection == null) { // Never happened\n      alert('selection is null');\n      return;\n    }\n    const position = selection.getPosition();\n    const range: monaco.IRange = {\n      startLineNumber: position.lineNumber,\n      endLineNumber: position.lineNumber,\n      startColumn: position.column,\n      endColumn: position.column,\n    };\n    editor.getModel()?.pushEditOperations(\n      [selection],\n      [\n        {\n          range,\n          text: codeSnippet,\n        }\n      ],\n      (_) => null,\n    ); // second parameter set to true to enable undo's\n    editor.focus();\n  }\n\n  summonDuck(): void {\n    this.setState({needDuck: true});\n  }\n\n  exileDuck(): void {\n    this.setState({needDuck: false});\n  }\n\n  async onStart(): Promise<void> {\n    if (!(await this.connect(connectByPariedDevice())))\n      await this.connect(connectBySelection());\n    //this.connect(connectByPlugIn());\n  }\n\n  removeErrorLineOfCode(): void {\n    const editor = this.state.editor!;\n    const ids = this.state.errorMonacoIDs;\n    if (ids != null) {\n      this.exileDuck();\n      editor.deltaDecorations(ids, []);\n      this.setState({\n        errorMonacoIDs: null\n      });\n    }\n  }\n\n  async onExec(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    // Notify the device that the connected micro:bit is now busy\n    this.setState({});\n\n    await outputStream.forEach(output => {\n      switch (output.kind) {\n        case 'NormalOutput':\n          this.setState({\n            output: output.outputChunk,\n            errorString: ''\n          });\n          break;\n        case 'ResetPressed':\n          console.log('ResetPressed');\n          break;\n        case 'ErrorMessage':\n          if (output.type !== 'KeyboardInterrupt') {\n            console.log(output.message);\n            const editor = this.state.editor!;\n            const errorMonacoID = editor.deltaDecorations([],\n              [\n                {\n                  range: new monaco.Range(output.line, 1, output.line, 1),\n                  options: {\n                    isWholeLine: true,\n                    className: 'Monaco-Error-Line-Of-Code'\n                  }\n                },\n              ]\n            );\n            this.setState({\n              errorString: 'Error on line ' + output.line + ':\\n' + output.type + ': ' + output.message,\n              errorLine: output.line,\n              errorMonacoIDs: errorMonacoID\n            });\n            this.summonDuck();\n          }\n      }\n    });\n\n    // Notify the app that the connection has freed up\n    this.setState({});\n  }\n\n  async onFlash(code: string): Promise<void> {\n    console.log('onFlash');\n    this.removeErrorLineOfCode();\n    await this.onExec(await this.state.connection!.interact.flash(code));\n  }\n\n  async onRun(code: string): Promise<void> {\n    console.log('onRun');\n    this.removeErrorLineOfCode();\n    await this.onExec(await this.state.connection!.interact.execute(code));\n  }\n\n  /**\n   * Execute the supplied code, and return a promise resolving to the output\n   * stream of the micro:bit running the code.\n   */\n  async onRunCell(code: string): Promise<Stream<MicrobitOutput>> {\n    console.log('onRunCell');\n    return await this.state.connection!.interact.execute(code);\n  }\n\n  async onReboot(): Promise<void> {\n    console.log('onReboot');\n    this.removeErrorLineOfCode();\n    await this.onExec(await this.state.connection!.interact.reboot());\n  }\n\n  async onInterrupt(): Promise<void> {\n    await this.state.connection!.interact.interrupt();\n\n    // Notify the app that the connection has freed up\n    this.setState({});\n  }\n}\n\nexport default APIDemo;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport APIDemo from './components/APIDemo';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <APIDemo/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}