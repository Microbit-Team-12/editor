{"version":3,"sources":["api/microbit-api.ts","api/microbit-api-config.ts","api/microbit/helper/serial/parser.ts","api/microbit/helper/serial/reader.ts","api/microbit/interact.ts","api/microbit/connect.ts","components/DocsViewer.tsx","components/APIDemo.tsx","index.tsx"],"names":["MicrobitState","defaultConfig","connectOption","baudRate","dataBits","stopBits","parity","bufferSize","flowControl","requestOption","filters","usbVendorId","readOption","showLog","updateMs","cutLength","signalOption","replLineReady","executionDone","executionStart","mainPYException","execException","waitMsBeforeReboot","SerialParser","portReader","config","signal","startSignals","endSignals","this","safeReadUntil","outputStream","a","console","log","safeReadUntilWithUpdate","str","readErrors","result","write","kind","outputChunk","end","unsafeReadline","line1","lineNumberString","split","lineCount","messageLine","startsWith","line2split","line","parseInt","type","message","SerialReader","serialBuffer","termination","read","value","bufferLimit","len","length","substring","token","index","indexOf","before","substr","readLoop","includes","splitBufferOnFirst","readLoopWithCut","tokens","update","bufferUpdated","matchedTokenID","forEach","updateTimer","setInterval","clearInterval","ConnectedMicrobitInteract","port","portWriter","portParser","state","portWriterStreamClosed","portReaderStreamClosed","Free","writable","encoder","TextEncoderStream","readable","pipeTo","catch","_","getWriter","decoder","TextDecoderStream","getReader","portReaderHelper","code","replace","readUntilNewREPLLine","Busy","Error","codeInPythonString","codeToPythonString","Stream","getREPLLine","readUntilExecStart","readUntilExecDone","then","interrupt","cond","Promise","resolve","reject","timer","waitUntil","cancel","abort","close","createConnection","open","reason","portInteract","interact","disconnection","addEventListener","onDisconnect","removeEventListener","connectBySelection","navigator","serial","requestPort","connectByPariedDevice","getPorts","ports","connectByPlugIn","checkUSBInfo","info","undefined","f","usbProductId","waitForPort","event","target","getInfo","PythonCode","props","isExpandable","highlightStart","highlightEnd","lines","isExpanded","fragments","lineNumbers","start","isNaN","setState","onFlash","onLoad","slice","join","className","style","darcula","language","showLineNumbers","IconButton","onClick","onExpand","bind","disabled","Height","FlashOn","DoubleArrow","React","Component","DocsViewer","renderers","renderCode","markdown","APIDemo","docs","output","connection","editor","alert","loader","init","t","disconnect","Box","paddingLeft","Button","variant","onStart","text","callback","renderStartButton","renderButtonRequiringConnection","onRun","getValue","onInterrupt","onReboot","defaultLanguage","defaultValue","onMount","handleEditorDidMount","theme","options","minimap","enabled","fontSize","wrapperClassName","readOnly","c","connect","codeSnippet","selection","getSelection","position","getPosition","range","startLineNumber","lineNumber","endLineNumber","startColumn","column","endColumn","getModel","pushEditOperations","focus","flash","onExec","execute","reboot","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b1d721e1.chunk.js","sourcesContent":["import Stream from 'ts-stream';\n\n/**\n * A description of connection failure\n*/\nexport interface FailedConnection {\n  readonly kind: 'ConnectionFailure',\n  readonly type: 'Failed to Obtain Port' | 'Failed to Open Port' | 'Port No Response'\n  readonly reason: string\n}\n\nexport interface MicrobitConnection {\n  readonly kind: 'MicrobitConnection'\n  /**\n   * An object that allows us to interact with the connected micro:bit.\n   */\n  readonly interact: InteractWithConnectedMicrobit\n\n  /**\n   * A promise that completes when the micro:bit connection is no longer active.\n   * This promise itself does not try to disconnect micro:bit.\n   */\n  readonly disconnection: Promise<void>\n}\n\nexport enum MicrobitState{\n  /**\n   * Nothing is running,\n   * \n   * Allowed: flash/execute/reboot\n   * \n   * Not Allowed: interrupt\n   */\n  Free,\n  /**\n   * Code is running,\n   * \n   * Allowed: Interrupt/reboot\n   * \n   * Not Allowed: flash/execute\n   */\n  Busy\n}\n\nexport interface InteractWithConnectedMicrobit {\n  /**\n   * Return State of Microbit in `MicrobitState`\n   */\n  getState(): MicrobitState\n\n  /**\n   * Flash ROM of the connected micro:bit.\n   * \n   * The flashing consists of two stages of flashing the code followed by a reboot.\n   * The promise completes when reboot is done, resulting in a stream of outputs from microbit.\n   */\n  flash: (code: string) => Promise<Stream<MicrobitOutput>>\n\n  /**\n   * Run code in REPL.\n   * Microbit is not rebooted. So all previous variables are kept.\n   */\n  execute: (code: string) => Promise<Stream<MicrobitOutput>>\n\n  /**\n   * Reboots the connected micro:bit.\n   * The promise completes with a stream of outputs from microbit.\n   */\n  reboot: () => Promise<Stream<MicrobitOutput>>\n\n  /**\n   * Send an interrupt signal the connected micro:bit.\n   * This will try to stop any python code running on the micro:bit.\n   * \n   * The promise completes when the interruption is successful.\n   * If code is being executed, then there should be a ErrorMessage in the outputStream.\n   */\n  interrupt: () => Promise<void> \n\n  /**\n   * Disconnect the paired micro:bit.\n   */\n  disconnect: () => Promise<void>\n}\n\n/**\n * Data that we expect to receive from micro:bit as a result of execututing the flashed code.\n */\nexport type MicrobitOutput = NormalOutput | ErrorMessage | ResetPressed\n\n/**\n * A piece of content that is output to the standard output of micro:bit.\n */\nexport interface NormalOutput {\n  readonly kind: 'NormalOutput'\n  /**\n   * outputChunk is a new piece of output we have obtained from micro:bit,\n   * and may not correspond to a single print() executed on the device.\n   */\n  readonly outputChunk: string\n}\n\n/**\n * An object indicate reset button is pressed on the microbit\n * \n * OutputStream will continue to output\n */\nexport interface ResetPressed{\n  readonly kind: 'ResetPressed'\n}\n\nexport type MicroPythonExceptionType = 'AssertionError'\n  | 'AttributeError'\n  | 'Exception'\n  | 'ImportError'\n  | 'IndexError'\n  | 'KeyboardInterrupt'\n  | 'KeyError'\n  | 'MemoryError'\n  | 'NameError'\n  | 'NotImplementedError'\n  | 'OSError'\n  | 'RuntimeError'\n  | 'StopIteration'\n  | 'SyntaxError'\n  | 'SystemExit'\n  | 'TypeError'\n  | 'ValueError'\n  | 'ZeroDivisionError'\n  | 'IndentationError'\n\n/**\n * A description of a runtime error that occured on micro:bit\n */\nexport interface ErrorMessage {\n  readonly kind: 'ErrorMessage'\n  /**\n   * A integer indicating in which line of user code the error occurs\n   */\n  readonly line: number\n  /**\n   * A string indicating type of the exception\n   * For full list of types, see\n   * https://docs.micropython.org/en/latest/library/builtins.html#exceptions\n   */\n  readonly type: MicroPythonExceptionType\n  /**\n   * A *simple* explanation of the error\n   */\n  readonly message: string\n}\n","//TODO: Rename\n\nexport interface ManagerOption {\n  /**\n   * Parameter used to connect serial port. See `SerialOptions`\n   */\n  connectOption: SerialOptions\n  /**\n   * Parameter used for filtering serial port. See `SerialPortRequestOptions`\n   */\n  requestOption: SerialPortRequestOptions\n  /**\n   * Parameter used for reader class\n   */\n  readOption: readOption\n  /**\n   * Parameter used for parser class\n   */\n  signalOption: SignalOption\n}\n\nexport interface readOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * Program output should be updated to the web every `updateMs` ms.\n   */\n  updateMs: number\n  /**\n   * Length of program output that should be kept.\n   * \n   * It is recommended to set this to 2 * maximum number of character in the textarea.\n   */\n  cutLength: number\n}\n\nexport interface SignalOption {\n  /**\n   * If log should be printed to console\n   */\n  showLog: boolean,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating waiting for user input code\n   */\n  replLineReady: string,\n  /**\n   * A string to be printed by `print` statement\n   * Before execution of user code\n   * Outputting is implemented by adding print statement before user code\n   */\n  executionStart: string,\n  /**\n   * A string to be printed by `print` statement \n   * After execution of given user code\n   * Outputting is implemented by adding print statement after user code\n   */\n  executionDone: string,\n  /**\n   * A string printed by microbit serial repl\n   * Indicating an error occured\n   */\n  mainPYException: string,\n  execException: string,\n  /**\n   * Ms before microbit is rebooted to run `main.py`\n   * Allowing output buffer to be emptied before reboot\n   * \n   * Not used right now\n   */\n  waitMsBeforeReboot: number,\n}\n\nexport const defaultConfig: ManagerOption = {\n  connectOption: {\n    baudRate: 115200,\n    dataBits: 8,\n    stopBits: 1,\n    parity: 'none',\n    bufferSize: 4096,\n    flowControl: 'none'\n  },\n  requestOption: {\n    filters: [\n      { usbVendorId: 0x0d28 }\n    ]\n  },\n  readOption: {\n    showLog: true,\n    updateMs: 50,\n    cutLength: 1000\n  },\n  //maybe consider using regexp?\n  signalOption: {\n    showLog: true,\n    replLineReady: '>>> ',\n    executionDone: 'Execute Done: 0x3f3f3f3f',\n    executionStart: 'Execution Start: 0x3f3f3f3f',\n    mainPYException: 'Traceback (most recent call last):\\r\\n  File \"main.py\", line ',\n    execException:   'Traceback (most recent call last):\\r\\n  File \"<stdin>\", line 1, in <module>\\r\\n  File \"<string>\", line ',\n    waitMsBeforeReboot: 1\n  }\n};","import Stream from 'ts-stream';\nimport { MicrobitOutput, MicroPythonExceptionType } from '../../../microbit-api';\nimport { SignalOption } from '../../../microbit-api-config';\nimport { SerialReader } from './reader';\n\n/**\n * This class provides functions to read serial output of a specific procedure,\n * by using the reader helper class.\n * \n * Below is its mechaism. Based on following input of code\n * ```\n * 1|Get REPL Line|>>>\n * 2|Setup Code   |>>> file=open('main.py','w');s='print(executionStart)\\\\r\\\\nprint(1)\\\\r\\\\nprint(executionStart)';file.write(s);file.close();from microbit import *;sleep(0);reset();\n * 3|#Byte Written|8\n * 4|executionStart\n * 5|Code output  |1\n * 6|executionDone\n * 6|MicroPython v1.13 on 2021-02-19; micro:bit v2.0.0-beta.4 with nRF52833\n * 7|Type \"help()\" for more information.\n * 8|>>>\n * ```\n * \n * Error Sample (Flashing)\n * ```\n * Traceback (most recent call last):\n * File \"main.py\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n *\n * REPL Sample (Running)\n * ```\n * Traceback (most recent call last):\n * File \"<stdin>\", line 1, in <module>\n * File \"<string>\", line 1, in <module>\n * NameError: name 'prit' isn't defined\n * ```\n */\nexport class SerialParser {\n  portReader: SerialReader;\n  signal: SignalOption;\n  startSignals: string[];\n  endSignals: string[];\n\n  constructor(portReader: SerialReader, config: SignalOption) {\n    this.portReader = portReader;\n    this.signal = config;\n    this.startSignals = [\n      config.executionStart + '\\r\\n',\n      config.mainPYException,\n      config.execException\n    ];\n    this.endSignals = [\n      config.executionDone + '\\r\\n',\n      config.executionStart + '\\r\\n',\n      config.mainPYException,\n      config.execException\n    ];\n\n  }\n\n  /**\n   * Read until new repl line is ready\n   */\n  readUntilNewREPLLine(): Promise<void> {\n    return this.portReader.safeReadUntil(this.signal.replLineReady);\n  }\n\n  /**\n   * Read until executionStart appears on serial\n   * - If there is no error, this Returns true \n   * - If (indentation/bracket) error occurs, the stream will be closed and false is returned\n   */\n  async readUntilExecStart(outputStream: Stream<MicrobitOutput>): Promise<boolean>{\n    console.log('Waiting for Execution Start');\n    const result = await this.portReader.safeReadUntilWithUpdate(\n      this.startSignals,\n      str => null\n    );\n    if (result !== 0) {\n      this.readErrors(outputStream);\n      return false;\n    }else return true;\n  }\n\n  /**\n   * Read output of user code, periodcally update output to stream\n   * \n   * Require executeStart printed earlier\n   */\n  async readUntilExecDone(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    console.log('Execution Start');\n    //Now user code will run\n    //read until executionEnd signal appear on signal\n    let result = 1;\n    while (result===1){\n      result = await this.portReader.safeReadUntilWithUpdate(\n        this.endSignals,\n        str => outputStream.write({\n          kind: 'NormalOutput',\n          outputChunk: str\n        })\n      );\n      if(result === 1) outputStream.write({\n        kind: 'ResetPressed'\n      });\n    }\n    if (result !== 0) this.readErrors(outputStream);\n    else outputStream.end();\n    console.log('Execution done');\n  }\n\n  /**\n   * Read and parse micropython error output\n   */\n  async readErrors(outputStream: Stream<MicrobitOutput>):Promise<void>{\n    console.log('Execution Error');\n    //line1 indicates in which line of user code exception occured\n    //which is first line after mainPYException and execException\n    const line1 = await this.portReader.unsafeReadline();\n    const lineNumberString = line1.split(',', 2)[0];\n    //messageLine is in the form of 'ErrorType:ErrorMessage'\n    //exec is used in user code, the line following line1 may not be mssageLine\n    let lineCount = 0;\n    let messageLine = '';\n    while (lineCount===0 || messageLine.startsWith('  ')) {\n      messageLine = await this.portReader.unsafeReadline();\n      lineCount+=1;\n    }\n    const line2split = messageLine.split(': ');\n    outputStream.write({\n      kind: 'ErrorMessage',\n      line: parseInt(lineNumberString) - 1,\n      type: line2split[0] as MicroPythonExceptionType,\n      message: (lineCount === 1) ? '' :'In eval, '+line2split[1]\n    });\n    outputStream.end();\n  }\n}","import { readOption } from '../../../microbit-api-config';\n/**\n * This class provide convenient function for reading serial output.\n */\nexport class SerialReader {\n  private serialBuffer = ''\n  private portReader: ReadableStreamDefaultReader<string>\n  private config: readOption\n\n  constructor(portReader: ReadableStreamDefaultReader<string>, config: readOption) {\n    this.portReader = portReader;\n    this.config = config;\n  }\n\n  /**\n   * Read from serial until termination is true.\n   * \n   * Buffer will not be cut in this function.\n   */\n  private async readLoop(termination: (text: string) => boolean): Promise<void> {\n    if(this.config.showLog) console.log(this.serialBuffer);\n    while (!termination(this.serialBuffer)) {\n      const { value } = await this.portReader.read();\n      this.serialBuffer += value;\n      if (this.config.showLog) console.log(this.serialBuffer);\n    }\n  }\n\n  /**\n   * Read from serial until termination is true.\n   * \n   * Assuming only last *bufferLimit* characters decides termination,\n   * this readLoop cuts unnecessary part of the buffer\n   */\n  private async readLoopWithCut(termination: (text: string) => boolean, bufferLimit: number): Promise<void> {\n    if (this.config.showLog) console.log(this.serialBuffer);\n    while (!termination(this.serialBuffer)) {\n      const len = this.serialBuffer.length;\n      if (len >= bufferLimit) this.serialBuffer = this.serialBuffer.substring(len - bufferLimit);\n      const { value } = await this.portReader.read();\n      this.serialBuffer += value;\n      if (this.config.showLog) console.log(this.serialBuffer);\n    }\n  }\n\n  /**\n   * Split *buffer* on first occurence of token.\n   * \n   * PRE: buffer = before + token + after\n   * buffer = after\n   * return before\n   */\n  private splitBufferOnFirst(token: string): string {\n    const index = this.serialBuffer.indexOf(token);\n    const before = this.serialBuffer.substr(0, index);\n    this.serialBuffer = this.serialBuffer.substr(index + token.length);\n    return before;\n  }\n\n  /**\n   * This function read a line from serial, \n   * and returns that line. \n   * \n   * You should only use this function when you are certain about what's comming from serial.\n   */\n  async unsafeReadline(): Promise<string> {\n    const token = '\\r\\n';\n    await this.readLoop(str => str.includes(token));\n    return this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until token appears in serial output, and returns nothing.\n   * \n   * Reading is optimized by cutting unnecessary string,\n   * so length of buffer < length of token.\n   * \n   * This is useful when reading potential long output,\n   * and the content before token does not matter\n   */\n  async safeReadUntil(token: string): Promise<void> {\n    await this.readLoopWithCut(str => str.includes(token), token.length);\n    this.splitBufferOnFirst(token);\n  }\n\n  /**\n   * This function reads until one of the token from the token array appears in serial output,\n   * and returns the token that appear in serial.\n   * Its content is also periodcally updates to upstream and when the token appears. \n   * \n   * This is useful when reading potential long output,\n   * and recent content of some length matters. \n   * \n   * Consider the following cases, which make the implementation necessary.\n   * \n   * `while True: print(1)` \n   * A lot of output\n   * \n   * `a=input(\"You name:\")` \n   * New content only come out after every thing gets outputted\n   * (So user can input)\n   */\n  async safeReadUntilWithUpdate(tokens: Array<string>, update: (text: string) => void): Promise<number> {\n    let bufferUpdated = false;\n    let matchedTokenID = -1;\n    const termination = (str: string) => {\n      bufferUpdated = true;\n      tokens.forEach((token,index) => { if (str.includes(token)) matchedTokenID = index; });\n      return matchedTokenID !== -1;\n    };\n    const updateTimer = setInterval(() => {\n      if (bufferUpdated) {\n        update(this.serialBuffer);\n        bufferUpdated = false;\n      }\n    }, this.config.updateMs);\n    await this.readLoopWithCut(termination, this.config.cutLength);\n    clearInterval(updateTimer);\n    update(this.splitBufferOnFirst(tokens[matchedTokenID]));\n    return matchedTokenID;\n  }\n}\n","import Stream from 'ts-stream';\nimport { InteractWithConnectedMicrobit, MicrobitOutput, MicrobitState } from '../microbit-api';\nimport { ManagerOption, SignalOption } from '../microbit-api-config';\nimport { SerialParser } from './helper/serial/parser';\nimport { SerialReader } from './helper/serial/reader';\nconst ctrlC = '\\x03';\n\nexport class ConnectedMicrobitInteract implements InteractWithConnectedMicrobit {\n  port: SerialPort;\n  portWriter!: WritableStreamDefaultWriter<string>;\n  portReader!: ReadableStreamDefaultReader<string>;\n  portParser!: SerialParser\n  signal: SignalOption;\n  state: MicrobitState;\n\n  private portWriterStreamClosed: Promise<void> | null = null;\n  private portReaderStreamClosed: Promise<void> | null = null;\n\n  constructor(port: SerialPort, config: ManagerOption) {\n    this.port = port;\n    this.signal = config.signalOption;\n    this.state = MicrobitState.Free;\n    if (port.writable != null) {\n      const encoder = new TextEncoderStream();\n      this.portWriterStreamClosed = encoder.readable.pipeTo(port.writable)\n        .catch((_) => { console.log('disconnected in pipe'); });\n      this.portWriter = encoder.writable.getWriter();\n    }\n    if (port.readable != null) {\n      const decoder = new TextDecoderStream();\n      this.portReaderStreamClosed = port.readable.pipeTo(decoder.writable)\n        .catch((_) => { console.log('disconnected in pipe'); });\n      this.portReader = decoder.readable.getReader();\n\n      const portReaderHelper = new SerialReader(this.portReader, config.readOption);\n      this.portParser = new SerialParser(portReaderHelper, config.signalOption);\n    }\n  }\n\n  getState(): MicrobitState {\n    return this.state;\n  }\n\n  /**\n   * Convert a javascript string of python code to readable python code\n   */\n  private codeToPythonString(code: string): string {\n    /* \n    replaceAll From up to down\n      (1) user-used escape character. e.g. [\\][t]\n        This should still be [\\][t] in main.py\n        [\\][\\][t] in python string\n      (2) user-used [']\n        Because code is wrapped with ''\n        [\\]['] in python string\n      (3) new line created by user\n        Should be [\\r][\\n] in main.py\n        [\\][r][\\][n] in python string\n    */\n    return (\n      'print(\\'' + this.signal.executionStart + '\\')'\n      + '\\r\\n' + code + '\\r\\n'\n      + 'print(\\'' + this.signal.executionDone + '\\')'\n    ) .replace(/\\\\/g,'\\\\\\\\')\n      .replace(/'/g,'\\\\\\'')\n      .replace(/\\r?\\n/g, '\\\\r\\\\n');\n  }\n\n  /**\n   * Send ctrlC to stop code execution\n   * - If no code was running, new REPL line starts\n   * - If code was running, then keyboardInterrupt appears\n   *    Serial input unavaible for a few ms, then new REPL line starts.\n   * Returns when the REPL line is clean and usable\n   */\n  private async getREPLLine(): Promise<void> {\n    await this.portWriter.write(ctrlC);\n    await this.portParser.readUntilNewREPLLine();\n  }\n\n  async flash(code: string): Promise<Stream<MicrobitOutput>> {\n    /*Whole procedure with workaround note\n      - Get a clean REPL line, see getREPLLine()\n      - Send code to `main.py` to REPL\n          Observation: Microbit serial lose characters when multiple lines are inputted\n          Workaround: Put all code on one line\n          The logic might be:\n            Microbit does not have enough pin on the chip for serial hardware flow control.\n            So computer has no way of knowing microbit buffer is full.\n            And when the buffer is full, microbit serial start to lose character.\n\n            When all code is on one line, microbit does not do any hard work until \\r entered\n            Less likely for the buffer to be full and lose character\n      - Print(replDone)\n          On receving replDone, manager knows microbit finished writing to main.py\n          It is rebooting and all later output are program output\n      - Sleep for 0ms\n          In case there are characters in output buffer\n      - reboot\n          To run `main.py` in a fresh state\n    */\n    if (this.state === MicrobitState.Busy) throw Error('Flash Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'file=open(\\'main.py\\',\\'w\\');'\n      + 's=\\'' + codeInPythonString + '\\';'\n      + 'file.write(s);'\n      + 'file.close();'\n      + 'from microbit import *;'\n      + 'reset()\\r'\n    );\n    if (await this.portParser.readUntilExecStart(outputStream)) {\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => { this.state = MicrobitState.Free; })\n        .catch(() => { outputStream.end(); });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  async execute(code: string): Promise<Stream<MicrobitOutput>> {\n    if (this.state === MicrobitState.Busy) throw Error('Execute Failed: Device not free');\n    this.state = MicrobitState.Busy;\n\n    const codeInPythonString = this.codeToPythonString(code);\n    const outputStream = new Stream<MicrobitOutput>();\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      's=\\'' + codeInPythonString + '\\';'\n      + 'exec(s)\\r'\n    );\n    if(await this.portParser.readUntilExecStart(outputStream)){\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => { this.state = MicrobitState.Free; })\n        .catch(() => { outputStream.end(); });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  async reboot(): Promise<Stream<MicrobitOutput>> {\n    if(this.state===MicrobitState.Busy) await this.interrupt().catch(()=>null);\n    this.state = MicrobitState.Busy;\n\n    await this.getREPLLine();\n    await this.portWriter.write(\n      'from microbit import *;'\n      + 'reset()\\r'\n    );\n    const outputStream = new Stream<MicrobitOutput>();\n    if (await this.portParser.readUntilExecStart(outputStream)) {\n      this.portParser.readUntilExecDone(outputStream)\n        .then(() => { this.state = MicrobitState.Free; })\n        .catch(() => { outputStream.end(); });\n    } else this.state = MicrobitState.Free;\n    return outputStream;\n  }\n\n  private waitUntil(cond: () => boolean): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timer = setInterval(() => {\n        if (cond()) {\n          clearInterval(timer);\n          resolve();\n        }\n      }, 200);\n    });\n  }\n\n  async interrupt(): Promise<void> {\n    if (this.state === MicrobitState.Free) throw Error('Interupt Failed: Device not running code');\n    await this.portWriter.write(ctrlC);\n    await this.waitUntil(() => this.state === MicrobitState.Free);\n    //Not reading for new REPL line here\n    //because portParser might already be reading.\n  }\n\n  async disconnect(): Promise<void> {\n    console.log('Disconnection initiated:');\n\n    await this.portReader.cancel('App will unmount');\n    await this.portReaderStreamClosed;\n    console.log('Reader closed;');\n\n    await this.portWriter.abort('App will unmount');\n    await this.portWriterStreamClosed;\n    console.log('Writer closed.');\n\n    await this.port.close();\n  }\n}","import { serial } from 'web-serial-polyfill';\nimport { FailedConnection, MicrobitConnection } from '../microbit-api';\nimport { defaultConfig, ManagerOption } from '../microbit-api-config';\nimport { ConnectedMicrobitInteract } from './interact';\n\n/**\n * Check if browser support WebSerial\n * Return true if WebSerial is supported\n * \n * If WebSerial is not supported but WebUSB is supported,\n * this function applys polyfill from Google.\n */\nexport function checkCompatability(): boolean {\n  if ('serial' in navigator) return true;\n  else {\n    if ('usb' in navigator) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (navigator as any).serial = serial;\n      return true;\n    } else return false;\n  }\n}\n\n/**\n * Given a unopenned serial port and configuration object,\n * Create a MicrobitConnection object\n */\nasync function createConnection(port: SerialPort, config: ManagerOption): Promise<MicrobitConnection | FailedConnection> {\n  try {\n    await port.open(config.connectOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Open Port',\n      reason: error.message\n    };\n  }\n  const portInteract = new ConnectedMicrobitInteract(port, config);\n  return {\n    kind: 'MicrobitConnection',\n    interact: portInteract,\n    disconnection: new Promise((resolve, _) => {\n      const onDisconnect = (_: Event) => {\n        console.log('disconnected');\n        port.removeEventListener('disconnect', onDisconnect);\n        resolve();\n      };\n      port.addEventListener('disconnect', onDisconnect);\n    })\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By selecting a serial port in the native permission window.\n * \n * **This must be followed by a UserGesture within a time period**\n * \n * *In some rare cases, calling other function before this can result in a UserGesture Error*\n */\nexport async function connectBySelection(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  let port: SerialPort;\n  try {\n    port = await navigator.serial.requestPort(config.requestOption);\n  } catch (error) {\n    return {\n      kind: 'ConnectionFailure',\n      type: 'Failed to Obtain Port',\n      reason: error.message\n    };\n  }\n  return createConnection(port, config);\n}\n\n/**\n * Create a MicrobitConnection object\n * By connecting to a paried serial device\n * This does not require selecting device in the native window.\n */\nexport async function connectByPariedDevice(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  const ports = await navigator.serial.getPorts();\n  if (ports.length === 1) return createConnection(ports[0], config);\n  else if(ports.length === 0) return {\n    kind: 'ConnectionFailure',\n    type: 'Failed to Obtain Port',\n    reason: 'No Paired Serial Devices Available'\n  }; else return {\n    kind: 'ConnectionFailure',\n    type: 'Failed to Obtain Port',\n    reason: 'Multiple Paired Serial Devices Available'\n  };\n}\n\n/**\n * Create a MicrobitConnection object\n * By user plugging the device\n */\nexport async function connectByPlugIn(config: ManagerOption = defaultConfig): Promise<MicrobitConnection | FailedConnection> {\n  //Given serialPortInfo, check if it agrees with filters\n  function checkUSBInfo(info: SerialPortInfo, filters: SerialPortFilter[] | undefined): boolean {\n    if (filters === undefined) return true; //no constraint\n    else {\n      for (const f of filters) {\n        //for two property, no constraint or equal\n        if (f.usbProductId === undefined || f.usbProductId === info.usbProductId)\n          if (f.usbVendorId === undefined || f.usbVendorId === info.usbVendorId)\n            return true;\n      }\n      return false;\n    }\n  }\n  \n  return new Promise((resolve, _) => {\n    /**\n     * A event listener function\n     * Resolves the promise when a device is plugged in\n     */\n    const waitForPort = async(event: Event) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const port: SerialPort = (event as any).port || event.target;\n      if (checkUSBInfo(port.getInfo(), config.requestOption.filters)) {\n        navigator.serial.removeEventListener('connect', waitForPort);\n        resolve(createConnection(port, config));\n      }\n    };\n    //add the listener\n    navigator.serial.addEventListener('connect', waitForPort);\n  });\n}","import React from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { darcula } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { DoubleArrow, FlashOn, Height } from '@material-ui/icons';\nimport { IconButton } from '@material-ui/core';\n\ntype PythonCodeProps = {\n  code: string,\n  onFlash?(code: string): Promise<void>,\n  onLoad(codeSnippet: string): void,\n}\n\ntype PythonCodeState = {\n  isExpanded: boolean,\n}\n\nclass PythonCode extends React.Component<PythonCodeProps, PythonCodeState> {\n  readonly isExpandable: boolean;\n  readonly highlightStart: number;\n  readonly highlightEnd: number;\n  readonly lines: string[];\n\n  constructor(props: PythonCodeProps) {\n    super(props);\n\n    this.state = {\n      isExpanded: false,\n    };\n\n    this.isExpandable = false;\n    this.lines = this.props.code.split('\\n');\n    this.highlightStart = 0;\n    this.highlightEnd = this.lines.length;\n\n    if (this.lines.length > 0) {\n      // Parse \"LINES x-y\". TODO consider using a parser later.\n      const fragments = this.lines[0].split('# LINES ');\n      if (fragments.length === 2) {\n        const lineNumbers = fragments[1].split('-');\n        const start = parseInt(lineNumbers[0]);\n        const end = parseInt(lineNumbers[1]);\n        if (!isNaN(start) && !isNaN(end)) {\n          this.highlightStart = start - 1; // indexing from 0\n          this.highlightEnd = end - 1 + 1; // end included\n          this.isExpandable = true;\n        }\n      }\n    }\n  }\n\n  onExpand(): void {\n    this.setState({isExpanded: !this.state.isExpanded});\n  }\n\n  async onFlash(): Promise<void> {\n    if (this.props.onFlash !== undefined)\n      await this.props.onFlash(this.props.code);\n  }\n\n  onLoad(): void {\n    this.props.onLoad(this.lines.slice(this.highlightStart, this.highlightEnd).join('\\n'));\n  }\n\n  render(): JSX.Element {\n    const [start, end] =\n      this.state.isExpanded ?\n        [0, this.lines.length] :\n        [this.highlightStart, this.highlightEnd];\n\n    return <div className=\"Docs-code\">\n      <SyntaxHighlighter\n        style={darcula}\n        language=\"py\"\n        showLineNumbers={this.state.isExpanded}\n        // Btw lineNumberContainerStyle can be used to remove the padding\n      >\n        {this.lines.slice(start, end).join('\\n')}\n      </SyntaxHighlighter>\n      <IconButton onClick={this.onExpand.bind(this)} disabled={!this.isExpandable}><Height/></IconButton>\n      <IconButton onClick={this.onFlash.bind(this)} disabled={this.props.onFlash === undefined}><FlashOn/></IconButton>\n      <IconButton onClick={this.onLoad.bind(this)}><DoubleArrow/></IconButton>\n    </div>;\n  }\n}\n\n\ntype DocsViewerProps = {\n  markdown: string,\n  onFlash?(code: string): Promise<void>,\n  onLoad(codeSnippet: string): void,\n}\n\ntype MarkdownCode = {\n  /** The language of the code block, specified by e.g. ```py ...``` */\n  language: string,\n  /** The contents of the code block */\n  value: string,\n}\n\nexport default class DocsViewer extends React.Component<DocsViewerProps, unknown> {\n  renderCode(code: MarkdownCode): JSX.Element {\n    if (code.language === 'py') {\n      return <PythonCode\n        code={code.value}\n        onFlash={this.props.onFlash}\n        onLoad={this.props.onLoad}\n      />;\n    } else {\n      return <SyntaxHighlighter\n        style={darcula}\n        language={code.language}\n      >\n        {code.value}\n      </SyntaxHighlighter>;\n    }\n  }\n\n  renderers = {code: this.renderCode.bind(this)};\n\n  render(): JSX.Element {\n    return <ReactMarkdown className=\"APIDemo-docs\" renderers={this.renderers}>\n      {this.props.markdown}\n    </ReactMarkdown>;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { Box, Button } from '@material-ui/core';\nimport Editor, { loader, Monaco } from '@monaco-editor/react';\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport React from 'react';\nimport { Stream } from 'ts-stream';\nimport { FailedConnection, MicrobitConnection, MicrobitOutput } from '../api/microbit-api';\nimport {\n  checkCompatability,\n  connectByPariedDevice, connectByPlugIn,\n  connectBySelection\n} from '../api/microbit/connect';\nimport './APIDemo.css';\nimport DocsViewer from './DocsViewer';\n\ntype APIDemoState = {\n  /** The markdown of the tutorial being displayed. */\n  docs: string,\n  output: string,\n  connection: MicrobitConnection | null,\n  editor: monaco.editor.IStandaloneCodeEditor | null,\n}\n\nconst exampleCode = `from microbit import *\nimport music\n\nwhile True:\n    if accelerometer.was_gesture('shake'):\n        display.show(Image.CONFUSED)\n        sleep(1500)\n    if accelerometer.was_gesture('face up'):\n        display.show(Image.HAPPY)\n    if accelerometer.was_gesture('left'):\n        display.show('<')\n        music.play(music.JUMP_UP)\n    if accelerometer.was_gesture('right'):\n        display.show('>')\n        music.play(music.JUMP_DOWN)\n`;\n\n\nconst exampleDocs = `# Title\n\nDid you know you can use tildes instead of backticks?\n\n~~~py\n# LINES 6-10\nfrom microbit import *\nimport music\n\nwhile True:\n    if button_a.is_pressed():\n        display.show(Image.MUSIC_QUAVER)\n        music.play(music.NYAN)\n    if button_b.is_pressed():\n        display.show(Image.MEH)\n        music.play(music.POWER_DOWN)\n    \n    display.show(Image.COW)\n~~~\n\nMore text\n`;\n\nclass APIDemo extends React.Component<unknown, APIDemoState> {\n  constructor(props: unknown) {\n    super(props);\n    this.state = {\n      docs: exampleDocs,\n      output: '',\n      connection: null,\n      editor: null,\n    };\n    if (!checkCompatability()) alert('Browser not supported');\n\n    loader.init().then(t=>{console.log(t);});\n  }\n\n  componentWillUnmount(): void {\n    this.state.connection?.interact.disconnect();\n  }\n\n  renderStartButton(): JSX.Element {\n    return <Box paddingLeft={2}>\n      <Button\n        className=\"APIDemo-button\"\n        variant=\"contained\"\n        disabled={this.state.connection !== null}\n        onClick={this.onStart.bind(this)}\n      >\n        Start\n      </Button>\n    </Box>;\n  }\n\n  renderButtonRequiringConnection(text: string, callback: () => void): JSX.Element {\n    return (\n      <Box paddingLeft={2}>\n        <Button\n          className=\"APIDemo-button\"\n          variant=\"contained\"\n          disabled={this.state.connection === null}\n          onClick={() => callback()}\n        >\n          {text}\n        </Button>\n      </Box>\n    );\n  }\n\n  handleEditorDidMount(editor: monaco.editor.IStandaloneCodeEditor, _: Monaco):void {\n    this.setState({\n      editor: editor,\n    });\n  }\n\n  render(): JSX.Element {\n    return (\n      <div className=\"APIDemo\">\n        <header className=\"APIDemo-header\">\n          {this.renderStartButton()}\n          {this.renderButtonRequiringConnection('Run Code', () => this.onRun(this.state.editor!.getValue()))}\n          {this.renderButtonRequiringConnection('Flash Code', () => this.onFlash(this.state.editor!.getValue()))}\n          {this.renderButtonRequiringConnection('Interrupt', this.onInterrupt.bind(this))}\n          {this.renderButtonRequiringConnection('Reboot', this.onReboot.bind(this))}\n        </header>\n        <div className=\"APIDemo-textareas\">\n          <DocsViewer\n            markdown={this.state.docs}\n            onFlash={this.state.connection === null ? undefined : this.onFlash.bind(this)}\n            onLoad={this.onLoad.bind(this)}\n          />\n\n          <Editor\n            defaultLanguage=\"python\"\n            defaultValue={exampleCode}\n            onMount={this.handleEditorDidMount.bind(this)}\n            theme='light'\n            options={{\n              minimap: {\n                enabled: false,\n              },\n              fontSize: 18,\n            }}\n            wrapperClassName=\"APIDemo-code\"\n          />\n\n          <textarea value={this.state.output} readOnly className=\"APIDemo-output\" />\n        </div>\n      </div>\n    );\n  }\n\n  async connect(connection: Promise<MicrobitConnection | FailedConnection>): Promise<boolean> {\n    const c = await connection;\n    switch (c.kind) {\n      case 'ConnectionFailure':\n        alert(c.reason);\n        return false;\n      case 'MicrobitConnection':\n        this.setState({ connection: c });\n        c.disconnection.then(async () => {\n          alert('Serial disconnected');\n          this.setState({ connection: null }, async () => {\n            await this.connect(connectByPlugIn());\n            alert('Serial reconnected');\n          });\n        });\n        return true;\n    }\n  }\n\n  onLoad(codeSnippet: string): void {\n    const editor = this.state.editor;\n    if (editor == null) {\n      alert('Editor is not loaded');\n      return;\n    }\n\n    const selection = editor.getSelection();\n    if (selection == null) {\n      alert('selection is null');\n      return;\n    }\n    const position = selection.getPosition();\n    const range: monaco.IRange = {\n      startLineNumber: position.lineNumber,\n      endLineNumber: position.lineNumber,\n      startColumn: position.column,\n      endColumn: position.column,\n    };\n    editor.getModel()?.pushEditOperations(\n      [selection],\n      [\n        {\n          range,\n          text: codeSnippet,\n        }\n      ],\n      (_) => null,\n    ); // second parameter set to true to enable undo's\n    editor.focus();\n  }\n\n\n  async onStart(): Promise<void> {\n    if (!(await this.connect(connectByPariedDevice())))\n      await this.connect(connectBySelection());\n    //this.connect(connectByPlugIn());\n  }\n\n  async onExec(outputStream: Stream<MicrobitOutput>): Promise<void> {\n    await outputStream.forEach(output => {\n      switch (output.kind){\n        case 'NormalOutput':\n          this.setState({\n            output: output.outputChunk\n          });\n          break;\n        case 'ResetPressed':\n          console.log('ResetPressed');\n          break;\n        case 'ErrorMessage':\n          if (output.type !== 'KeyboardInterrupt'){\n            alert('Error on line ' + output.line + ':\\n' + output.type + ': ' + output.message);\n          }\n      }\n    });\n  }\n\n  async onFlash(code: string): Promise<void> {\n    console.log('onFlash');\n    if (this.state.connection !== null) {\n      await this.onExec(await this.state.connection.interact.flash(code));\n    } else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onRun(code: string): Promise<void> {\n    console.log('onFlash');\n    if (this.state.connection !== null) {\n      await this.onExec(await this.state.connection.interact.execute(code));\n    } else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onReboot(): Promise<void> {\n    console.log('onReboot');\n    if (this.state.connection !== null) {\n      await this.onExec(await this.state.connection.interact.reboot());\n    } else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n\n  async onInterrupt(): Promise<void> {\n    if (this.state.connection !== null) {\n      await this.state.connection.interact.interrupt();\n    } else {\n      alert('No device is connected. Press \\'Start\\' to connect a device.');\n    }\n  }\n}\n\nexport default APIDemo;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport APIDemo from './components/APIDemo';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <APIDemo />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}